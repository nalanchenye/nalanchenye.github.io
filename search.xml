<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>源码解读 Golang 中 sync.Map 的实现原理</title>
      <link href="/2020/03/23/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%20Golang%20%E4%B8%AD%20sync.Map%20%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
      <url>/2020/03/23/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%20Golang%20%E4%B8%AD%20sync.Map%20%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Go 的内建 <code>map</code> 是不支持并发写操作的，原因是 <code>map</code> 写操作不是并发安全的，当你尝试多个 Goroutine 操作同一个 <code>map</code>，会产生报错：<code>fatal error: concurrent map writes</code>。</p><p>因此官方另外引入了 <code>sync.Map</code> 来满足并发编程中的应用。</p><p><code>sync.Map</code> 的实现原理可概括为：</p><ul><li>通过 read 和 dirty 两个字段将读写分离，读的数据存在只读字段 read 上，将最新写入的数据则存在 dirty 字段上</li><li>读取时会先查询 read，不存在再查询 dirty，写入时则只写入 dirty</li><li>读取 read 并不需要加锁，而读或写 dirty 都需要加锁</li><li>另外有 misses 字段来统计 read 被穿透的次数（被穿透指需要读 dirty 的情况），超过一定次数则将 dirty 数据同步到 read 上</li><li>对于删除数据则直接通过标记来延迟删除</li></ul><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p><code>Map</code> 的数据结构如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 加锁作用，保护 dirty 字段</span></span><br><span class="line">    mu Mutex</span><br><span class="line">    <span class="comment">// 只读的数据，实际数据类型为 readOnly</span></span><br><span class="line">    read atomic.Value</span><br><span class="line">    <span class="comment">// 最新写入的数据</span></span><br><span class="line">    dirty <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*entry</span><br><span class="line">    <span class="comment">// 计数器，每次需要读 dirty 则 +1</span></span><br><span class="line">    misses <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 readOnly 的数据结构为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> readOnly <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 内建 map</span></span><br><span class="line">    m  <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*entry</span><br><span class="line">    amended <span class="keyword">bool</span>  <span class="comment">// 表示 dirty 里存在 read 里没有的 key，通过该字段决定是否加锁读 dirty</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>entry</code> 数据结构则用于存储值的指针：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span><br><span class="line">    p unsafe.Pointer  <span class="comment">// 等同于 *interface&#123;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>属性 p 有三种状态：</p><ul><li><code>p == nil</code>: 键值已经被删除，且 <code>m.dirty == nil</code></li><li><code>p == expunged</code>: 键值已经被删除，但 <code>m.dirty!=nil</code> 且 <code>m.dirty</code> 不存在该键值（expunged 实际是空接口指针）</li><li>除以上情况，则键值对存在，存在于 <code>m.read.m</code> 中，如果 <code>m.dirty!=nil</code> 则也存在于 <code>m.dirty</code></li></ul><p><code>Map</code> 常用的有以下方法：</p><ul><li><code>Load</code>：读取指定 key 返回 value</li><li><code>Store</code>： 存储（增或改）key-value</li><li><code>Delete</code>： 删除指定 key</li></ul><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="Load"><a href="#Load" class="headerlink" title="Load"></a>Load</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Load</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(value <span class="keyword">interface</span>&#123;&#125;, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 首先尝试从 read 中读取 readOnly 对象</span></span><br><span class="line">    read, _ := m.read.Load().(readOnly)</span><br><span class="line">    e, ok := read.m[key]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不存在则尝试从 dirty 中获取</span></span><br><span class="line">    <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">        m.mu.Lock()</span><br><span class="line">        <span class="comment">// 由于上面 read 获取没有加锁，为了安全再检查一次</span></span><br><span class="line">        read, _ = m.read.Load().(readOnly)</span><br><span class="line">        e, ok = read.m[key]</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 确实不存在则从 dirty 获取</span></span><br><span class="line">        <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">            e, ok = m.dirty[key]</span><br><span class="line">            <span class="comment">// 调用 miss 的逻辑</span></span><br><span class="line">            m.missLocked()</span><br><span class="line">        &#125;</span><br><span class="line">        m.mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从 entry.p 读取值</span></span><br><span class="line">    <span class="keyword">return</span> e.load()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">missLocked</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m.misses++</span><br><span class="line">    <span class="keyword">if</span> m.misses &lt; <span class="built_in">len</span>(m.dirty) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当 miss 积累过多，会将 dirty 存入 read，然后 将 amended = false，且 m.dirty = nil</span></span><br><span class="line">    m.read.Store(readOnly&#123;m: m.dirty&#125;)</span><br><span class="line">    m.dirty = <span class="literal">nil</span></span><br><span class="line">    m.misses = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Store</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    read, _ := m.read.Load().(readOnly)</span><br><span class="line">    <span class="comment">// 如果 read 里存在，则尝试存到 entry 里</span></span><br><span class="line">    <span class="keyword">if</span> e, ok := read.m[key]; ok &amp;&amp; e.tryStore(&amp;value) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果上一步没执行成功，则要分情况处理</span></span><br><span class="line">    m.mu.Lock()</span><br><span class="line">    read, _ = m.read.Load().(readOnly)</span><br><span class="line">    <span class="comment">// 和 Load 一样，重新从 read 获取一次</span></span><br><span class="line">    <span class="keyword">if</span> e, ok := read.m[key]; ok &#123;</span><br><span class="line">        <span class="comment">// 情况 1：read 里存在</span></span><br><span class="line">        <span class="keyword">if</span> e.unexpungeLocked() &#123;</span><br><span class="line">            <span class="comment">// 如果 p == expunged，则需要先将 entry 赋值给 dirty（因为 expunged 数据不会留在 dirty）</span></span><br><span class="line">            m.dirty[key] = e</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 用值更新 entry</span></span><br><span class="line">        e.storeLocked(&amp;value)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> e, ok := m.dirty[key]; ok &#123;</span><br><span class="line">        <span class="comment">// 情况 2：read 里不存在，但 dirty 里存在，则用值更新 entry</span></span><br><span class="line">        e.storeLocked(&amp;value)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 情况 3：read 和 dirty 里都不存在</span></span><br><span class="line">        <span class="keyword">if</span> !read.amended &#123;</span><br><span class="line">            <span class="comment">// 如果 amended == false，则调用 dirtyLocked 将 read 拷贝到 dirty（除了被标记删除的数据）</span></span><br><span class="line">            m.dirtyLocked()</span><br><span class="line">            <span class="comment">// 然后将 amended 改为 true</span></span><br><span class="line">            m.read.Store(readOnly&#123;m: read.m, amended: <span class="literal">true</span>&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将新的键值存入 dirty</span></span><br><span class="line">        m.dirty[key] = newEntry(value)</span><br><span class="line">    &#125;</span><br><span class="line">    m.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">tryStore</span><span class="params">(i *<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        p := atomic.LoadPointer(&amp;e.p)</span><br><span class="line">        <span class="keyword">if</span> p == expunged &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> atomic.CompareAndSwapPointer(&amp;e.p, p, unsafe.Pointer(i)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">unexpungeLocked</span><span class="params">()</span> <span class="params">(wasExpunged <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> atomic.CompareAndSwapPointer(&amp;e.p, expunged, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">storeLocked</span><span class="params">(i *<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    atomic.StorePointer(&amp;e.p, unsafe.Pointer(i))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">dirtyLocked</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> m.dirty != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    read, _ := m.read.Load().(readOnly)</span><br><span class="line">    m.dirty = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*entry, <span class="built_in">len</span>(read.m))</span><br><span class="line">    <span class="keyword">for</span> k, e := <span class="keyword">range</span> read.m &#123;</span><br><span class="line">        <span class="comment">// 判断 entry 是否被删除，否则就存到 dirty 中</span></span><br><span class="line">        <span class="keyword">if</span> !e.tryExpungeLocked() &#123;</span><br><span class="line">            m.dirty[k] = e</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">tryExpungeLocked</span><span class="params">()</span> <span class="params">(isExpunged <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    p := atomic.LoadPointer(&amp;e.p)</span><br><span class="line">    <span class="keyword">for</span> p == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 如果有 p == nil（即键值对被 delete），则会在这个时机被置为 expunged</span></span><br><span class="line">        <span class="keyword">if</span> atomic.CompareAndSwapPointer(&amp;e.p, <span class="literal">nil</span>, expunged) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        p = atomic.LoadPointer(&amp;e.p)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p == expunged</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Delete</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    m.LoadAndDelete(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LoadAndDelete 作用等同于 Delete，并且会返回值与是否存在</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">LoadAndDelete</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(value <span class="keyword">interface</span>&#123;&#125;, loaded <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 获取逻辑和 Load 类似，read 不存在则查询 dirty</span></span><br><span class="line">    read, _ := m.read.Load().(readOnly)</span><br><span class="line">    e, ok := read.m[key]</span><br><span class="line">    <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">        m.mu.Lock()</span><br><span class="line">        read, _ = m.read.Load().(readOnly)</span><br><span class="line">        e, ok = read.m[key]</span><br><span class="line">        <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">            e, ok = m.dirty[key]</span><br><span class="line">            m.missLocked()</span><br><span class="line">        &#125;</span><br><span class="line">        m.mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查询到 entry 后执行删除</span></span><br><span class="line">    <span class="keyword">if</span> ok &#123;</span><br><span class="line">        <span class="comment">// 将 entry.p 标记为 nil，数据并没有实际删除</span></span><br><span class="line">        <span class="comment">// 真正删除数据并被被置为 expunged，是在 Store 的 tryExpungeLocked 中</span></span><br><span class="line">        <span class="keyword">return</span> e.<span class="built_in">delete</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>可见，通过这种读写分离的设计，解决了并发情况的写入安全，又使读取速度在大部分情况可以接近内建 <code>map</code>，非常适合读多写少的情况。</p><p><code>sync.Map</code> 还有一些其他方法：</p><ul><li><code>Range</code>：遍历所有键值对，参数是回调函数</li><li><code>LoadOrStore</code>：读取数据，若不存在则保存再读取</li></ul><p>这里就不再详解了，可参见 <a href="https://github.com/golang/go/blob/2e8dbae85ce88d02f651e53338984288057f14cb/src/sync/map.go" target="_blank" rel="noopener">源码</a>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经典面试题：青蛙跳台阶</title>
      <link href="/2020/03/09/%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6/"/>
      <url>/2020/03/09/%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>「剑指Offer」里的经典题目，近期群里聊到这题，特来复习一波。</p></blockquote><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先跳到 n 级台阶可以分解为两种情况：</p><ol><li>之前跳到 n-1 级台阶，然后再跳 1 级到达 n 级；</li><li>之前跳到 n-2 级台阶，然后再跳 2 级到达 n 级；</li></ol><p>因此 n 级跳法数量，等于这两种情况之和。<br>即 <code>F(n) = F(n-1) + F(n-2)</code>  </p><p>同理可继续推导：<br><code>F(n-1) = F(n-2) + F(n-3)</code><br><code>F(n-2) = F(n-3) + F(n-4)</code><br>…<br><code>F(2) = F(1) + F(0)</code><br><code>F(1) = 1</code><br><code>F(0) = 1</code>  </p><p>可见这是斐波那契数列，数列中从第三个数开始，每个数都是前两个数之和。那么只需从 <code>F(0) + F(1) = F(2)</code> 开始计算，一直加到 <code>F(n)</code> 即可得出结果。 </p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="Golang-版"><a href="#Golang-版" class="headerlink" title="Golang 版"></a>Golang 版</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">JumpFloor</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    a, b := <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> ; n &gt; <span class="number">0</span>; n-- &#123;  </span><br><span class="line">        a, b = b, a + b</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python-版"><a href="#Python-版" class="headerlink" title="Python 版"></a>Python 版</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">jump_floor</span><span class="params">(n)</span>:</span></span><br><span class="line">    a, b = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(n):</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">    <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 刷题 </tag>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>探究 Go 语言 defer 语句的三种机制</title>
      <link href="/2020/03/01/%E6%8E%A2%E7%A9%B6%20Go%20%E8%AF%AD%E8%A8%80%20defer%20%E8%AF%AD%E5%8F%A5%E7%9A%84%E4%B8%89%E7%A7%8D%E6%9C%BA%E5%88%B6/"/>
      <url>/2020/03/01/%E6%8E%A2%E7%A9%B6%20Go%20%E8%AF%AD%E8%A8%80%20defer%20%E8%AF%AD%E5%8F%A5%E7%9A%84%E4%B8%89%E7%A7%8D%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>Golang 的 1.13 版本 与 1.14 版本对 <code>defer</code> 进行了两次优化，使得 <code>defer</code> 的性能开销在大部分场景下都得到大幅降低，其中到底经历了什么原理？</p><p>这是因为这两个版本对 <code>defer</code> 各加入了一项新的机制，使得 <code>defer</code> 语句在编译时，编译器会根据不同版本与情况，对每个 <code>defer</code> 选择不同的机制，以更轻量的方式运行调用。</p><h3 id="堆上分配"><a href="#堆上分配" class="headerlink" title="堆上分配"></a>堆上分配</h3><p>在 Golang 1.13 之前的版本中，所有 <code>defer</code> 都是在堆上分配，该机制在编译时会进行两个步骤：</p><ol><li>在 <code>defer</code> 语句的位置插入 <code>runtime.deferproc</code>，当被执行时，延迟调用会被保存为一个 <code>_defer</code> 记录，并将被延迟调用的入口地址及其参数复制保存，存入 Goroutine 的调用链表中。</li><li>在函数返回之前的位置插入 <code>runtime.deferreturn</code>，当被执行时，会将延迟调用从 Goroutine 链表中取出并执行，多个延迟调用则以 jmpdefer 尾递归调用方式连续执行。</li></ol><p>这种机制的主要性能问题存在于每个 <code>defer</code> 语句产生记录时的内存分配，以及记录参数和完成调用时参数移动的系统调用开销。</p><h3 id="栈上分配"><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h3><p>Go 1.13 版本新加入 <code>deferprocStack</code> 实现了在栈上分配的形式来取代 <code>deferproc</code>，相比后者，栈上分配在函数返回后 <code>_defer</code> 便得到释放，省去了内存分配时产生的性能开销，只需适当维护 <code>_defer</code> 的链表即可。</p><p>编译器有自己的逻辑去选择使用 <code>deferproc</code> 还是 <code>deferprocStack</code>，大部分情况下都会使用后者，性能会提升约 30%。不过在 <code>defer</code> 语句出现在了循环语句里，或者无法执行更高阶的编译器优化时，亦或者同一个函数中使用了过多的 <code>defer</code> 时，依然会使用 <code>deferproc</code>。</p><h3 id="开放编码"><a href="#开放编码" class="headerlink" title="开放编码"></a>开放编码</h3><p>Go 1.14 版本继续加入了开发编码（open coded），该机制会将延迟调用直接插入函数返回之前，省去了运行时的 <code>deferproc</code> 或 <code>deferprocStack</code> 操作，在运行时的 <code>deferreturn</code> 也不会进行尾递归调用，而是直接在一个循环中遍历所有延迟函数执行。</p><p>这种机制使得 <code>defer</code> 的<strong>开销几乎可以忽略</strong>，唯一的运行时成本就是存储参与延迟调用的相关信息，不过使用此机制需要一些条件：</p><ol><li>没有禁用编译器优化，即没有设置 <code>-gcflags &quot;-N&quot;</code>；</li><li>函数内 <code>defer</code> 的数量不超过 8 个，且返回语句与延迟语句个数的乘积不超过 15；</li><li><code>defer</code> 不是在循环语句中。</li></ol><p>该机制还引入了一种元素 —— <strong>延迟比特（defer bit）</strong>，用于运行时记录每个 <code>defer</code> 是否被执行（尤其是在条件判断分支中的 <code>defer</code>），从而便于判断最后的延迟调用该执行哪些函数。 </p><p>延迟比特的原理：<br>同一个函数内每出现一个 <code>defer</code> 都会为其分配 1 个比特，如果被执行到则设为 1，否则设为 0，当到达函数返回之前需要判断延迟调用时，则用掩码判断每个位置的比特，若为 1 则调用延迟函数，否则跳过。</p><p>为了轻量，官方将延迟比特限制为 1 个字节，即 8 个比特，这就是为什么不能超过 8 个 <code>defer</code> 的原因，若超过依然会选择堆栈分配，但显然大部分情况不会超过 8 个。 </p><p>用代码演示如下： </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">deferBits = <span class="number">0</span>  <span class="comment">// 延迟比特初始值 00000000</span></span><br><span class="line"></span><br><span class="line">deferBits |= <span class="number">1</span>&lt;&lt;<span class="number">0</span>  <span class="comment">// 执行第一个 defer，设置为 00000001</span></span><br><span class="line">_f1 = f1  <span class="comment">// 延迟函数</span></span><br><span class="line">_a1 = a1  <span class="comment">// 延迟函数的参数</span></span><br><span class="line"><span class="keyword">if</span> cond &#123;</span><br><span class="line">    <span class="comment">// 如果第二个 defer 被执行，则设置为 00000011，否则依然为 00000001</span></span><br><span class="line">    deferBits |= <span class="number">1</span>&lt;&lt;<span class="number">1</span></span><br><span class="line">    _f2 = f2</span><br><span class="line">    _a2 = a2</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">exit:</span><br><span class="line"><span class="comment">// 函数返回之前，倒序检查延迟比特，通过掩码逐位进行与运算，来判断是否调用函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 假如 deferBits 为 00000011，则 00000011 &amp; 00000010 != 0，因此调用 f2</span></span><br><span class="line"><span class="comment">// 否则 00000001 &amp; 00000010 == 0，不调用 f2</span></span><br><span class="line"><span class="keyword">if</span> deferBits &amp; <span class="number">1</span>&lt;&lt;<span class="number">1</span> != <span class="number">0</span> &#123;</span><br><span class="line">    deferBits &amp;^= <span class="number">1</span>&lt;&lt;<span class="number">1</span>  <span class="comment">// 移位为下次判断准备</span></span><br><span class="line">    _f2(_a2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 同理，由于 00000001 &amp; 00000001 != 0，调用 f1</span></span><br><span class="line"><span class="keyword">if</span> deferBits &amp;&amp; <span class="number">1</span>&lt;&lt;<span class="number">0</span> != <span class="number">0</span> &#123;</span><br><span class="line">    deferBits &amp;^= <span class="number">1</span>&lt;&lt;<span class="number">0</span></span><br><span class="line">    _f1(_a1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以往 Golang defer 语句的性能问题一直饱受诟病，最近正式发布的  1.14 版本终于为这个争议画上了阶段性的句号。如果不是在特殊情况下，我们不需要再计较 defer 的性能开销。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>[1] Ou Changkun - Go 语言原本:<br><a href="https://changkun.de/golang/zh-cn/part2runtime/ch09lang/defer/" target="_blank" rel="noopener">https://changkun.de/golang/zh-cn/part2runtime/ch09lang/defer/</a></p><p>[2] 峰云就她了 - go1.14实现defer性能大幅度提升原理:<br><a href="http://xiaorui.cc/archives/6579" target="_blank" rel="noopener">http://xiaorui.cc/archives/6579</a></p><p>[3] 34481-opencoded-defers:<br><a href="https://github.com/golang/proposal/blob/master/design/34481-opencoded-defers.md" target="_blank" rel="noopener">https://github.com/golang/proposal/blob/master/design/34481-opencoded-defers.md</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十大经典排序算法整理汇总（附代码）</title>
      <link href="/2020/02/16/sort-algorithms/"/>
      <url>/2020/02/16/sort-algorithms/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt=""></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文整理并总结了十大经典的排序算法（冒泡排序、选择排序、插入排序、快速排序、归并排序、希尔排序、计数排序、基数排序、桶排序、堆排序）的时间复杂度、空间复杂度等性质。</p><p><strong>本文并不会详细讲解每种排序算法的原理</strong>，网上有很多很好的教程，大家可以自己去搜了看。</p><p>最后我还亲自手写了十种排序算法的 c++ 代码，大家可以用来通过 <a href="https://leetcode-cn.com/problems/sort-an-array/" target="_blank" rel="noopener" title="LeetCode 912. 排序数组">LeetCode 912. 排序数组</a> 这道题。</p><h2 id="性质汇总"><a href="#性质汇总" class="headerlink" title="性质汇总"></a>性质汇总</h2><blockquote><p>如果发现表中有错误，请留言告知。</p></blockquote><table><thead><tr><th>算法</th><th>最好</th><th>最坏</th><th>平均</th><th>空间</th><th align="center">稳定性</th><th align="center">是否基于比较</th></tr></thead><tbody><tr><td>冒泡排序</td><td>$O(n)$</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td align="center">$\checkmark$</td><td align="center">$\checkmark$</td></tr><tr><td>选择排序</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td align="center">$\times$</td><td align="center">$\checkmark$</td></tr><tr><td>插入排序</td><td>$O(n)$</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td align="center">$\checkmark$</td><td align="center">$\checkmark$</td></tr><tr><td>快速排序</td><td>$O(n\log n)$</td><td>$O(n^2)$</td><td>$O(n\log n)$</td><td>$O(\log n)$~$O(n)$</td><td align="center">$\times$</td><td align="center">$\checkmark$</td></tr><tr><td>归并排序</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(n)$</td><td align="center">$\checkmark$</td><td align="center">$\checkmark$</td></tr><tr><td>希尔排序</td><td>$O(n^{1.3})$</td><td>$O(n^2)$</td><td>$O(n\log n)$~$O(n^2)$</td><td>$O(1)$</td><td align="center">$\times$</td><td align="center">$\checkmark$</td></tr><tr><td>计数排序</td><td>$O(n+k)$</td><td>$O(n+k)$</td><td>$O(n+k)$</td><td>$O(n+k)$</td><td align="center">$\checkmark$</td><td align="center">$\times$</td></tr><tr><td>基数排序</td><td>$O(nk)$</td><td>$O(nk)$</td><td>$O(nk)$</td><td>$O(n+k)$</td><td align="center">$\checkmark$</td><td align="center">$\times$</td></tr><tr><td>桶排序</td><td>$O(n)$</td><td>$O(n)$</td><td>$O(n)$</td><td>$O(n+m)$</td><td align="center">$\checkmark$</td><td align="center">$\times$</td></tr><tr><td>堆排序</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(1)$</td><td align="center">$\times$</td><td align="center">$\checkmark$</td></tr></tbody></table><blockquote><p>如果表格显示有问题的话，还可以直接看下面的汇总图：</p></blockquote><p><img src="1.png" alt="十大经典排序算法性质汇总"></p><h3 id="维基百科"><a href="#维基百科" class="headerlink" title="维基百科"></a>维基百科</h3><p>我觉得还是英文维基百科讲的比较详细、严谨。如果大家看的比较累的话，可以自己百度搜索相应的教程。</p><p><strong>冒泡排序</strong><br><a href="https://en.wikipedia.org/wiki/Bubble_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Bubble_sort</a></p><p><strong>选择排序</strong><br><a href="https://en.wikipedia.org/wiki/Selection_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Selection_sort</a></p><p><strong>插入排序</strong><br><a href="https://en.wikipedia.org/wiki/Insertion_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Insertion_sort</a></p><p><strong>快速排序</strong><br><a href="https://en.wikipedia.org/wiki/Quicksort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Quicksort</a></p><p><strong>归并排序</strong><br><a href="https://en.wikipedia.org/wiki/Merge_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Merge_sort</a></p><p><strong>希尔排序</strong><br><a href="https://en.wikipedia.org/wiki/Shellsort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Shellsort</a></p><p><strong>计数排序</strong><br><a href="https://en.wikipedia.org/wiki/Counting_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Counting_sort</a></p><p><strong>基数排序</strong><br><a href="https://en.wikipedia.org/wiki/Radix_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Radix_sort</a></p><p><strong>桶排序</strong><br><a href="https://en.wikipedia.org/wiki/Bucket_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Bucket_sort</a></p><p><strong>堆排序</strong><br><a href="https://en.wikipedia.org/wiki/Heapsort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Heapsort</a></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>所有的排序算法接口都是相同的，也就是 <code>vector&lt;int&gt; xxxSort(vector&lt;int&gt;&amp; nums)</code> 。只需要你传入一个 <code>vector&lt;int&gt;</code> 类型的数组，就能返回排序后的结果。</p><p>运行下来可以发现，桶排序速度是比较快的。而冒泡排序、选择排序和插入排序因为时间复杂度太高无法通过本题，基数排序因为无法处理负数也不能通过本题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> quickSort(nums);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 冒泡排序（超时）</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">bubbleSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = n<span class="number">-2</span>; j &gt;= i; --j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &gt; nums[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                    swap(nums[j], nums[j+<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择排序（超时）</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">selectSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> idx = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[idx]) &#123;</span><br><span class="line">                    idx = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums[i], nums[idx]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入排序（超时）</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">insertSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; nums[j] &lt; nums[j<span class="number">-1</span>]; --j) &#123;</span><br><span class="line">                swap(nums[j], nums[j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快速排序（24 ms）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">qSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> m = l;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; r; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; nums[r]) &#123;</span><br><span class="line">                swap(nums[m++], nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums[m], nums[r]);</span><br><span class="line">        qSort(nums, l, m<span class="number">-1</span>);</span><br><span class="line">        qSort(nums, m+<span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">quickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        qSort(nums, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 归并排序（192 ms）</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">mSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> &#123;nums[l]&#125;;</span><br><span class="line">        <span class="keyword">int</span> m = l+(r-l)/<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; lnums = mSort(nums, l, m);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rnums = mSort(nums, m+<span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= m-l &amp;&amp; j &lt;= r-m<span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lnums[i] &lt; rnums[j]) &#123;</span><br><span class="line">                res.push_back(lnums[i++]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res.push_back(rnums[j++]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= m-l) &#123;</span><br><span class="line">            res.push_back(lnums[i++]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= r-m<span class="number">-1</span>) &#123;</span><br><span class="line">            res.push_back(rnums[j++]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">mergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        nums = mSort(nums, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 归并排序 + 非递归（80 ms）</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">mergeSortNR</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">1</span>; len &lt; n; len &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; n-len; l += <span class="number">2</span>*len) &#123;</span><br><span class="line">                <span class="keyword">int</span> m = l+len<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">int</span> r = min(n<span class="number">-1</span>, l+<span class="number">2</span>*len<span class="number">-1</span>);</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">                <span class="keyword">int</span> i = l, j = m+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (i &lt;= m &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums[i] &lt; nums[j]) &#123;</span><br><span class="line">                        res.push_back(nums[i++]);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        res.push_back(nums[j++]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (i &lt;= m) &#123;</span><br><span class="line">                    res.push_back(nums[i++]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (j &lt;= r) &#123;</span><br><span class="line">                    res.push_back(nums[j++]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) &#123;</span><br><span class="line">                    nums[i] = res[i-l];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 希尔排序（40 ms）</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">shellSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> gap = n/<span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; n; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j-gap &gt;= <span class="number">0</span> &amp;&amp; nums[j-gap] &gt; nums[j]; j -= gap) &#123;</span><br><span class="line">                    swap(nums[j-gap], nums[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计数排序（32 ms）</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (!n) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">int</span> minv = *min_element(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> maxv = *max_element(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> m = maxv-minv+<span class="number">1</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">count</span><span class="params">(m, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            count[nums[i]-minv]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; count[i]; ++j) &#123;</span><br><span class="line">                res.push_back(i+minv);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基数排序（不适用于负数）</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">radixSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> maxv = *max_element(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> maxd = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (maxv &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            maxv /= <span class="number">10</span>;</span><br><span class="line">            maxd++;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt; count(10, 0), rank(n, 0);</span><br><span class="line">        <span class="keyword">int</span> base = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (maxd &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            count.assign(<span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                count[(nums[i]/base)%<span class="number">10</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">                count[i] += count[i<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">                rank[--count[(nums[i]/base)%<span class="number">10</span>]] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                nums[i] = rank[i];</span><br><span class="line">            &#125;</span><br><span class="line">            maxd--;</span><br><span class="line">            base *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 桶排序 (20 ms)</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">bucketSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> maxv = *max_element(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> minv = *min_element(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> bs = <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">int</span> m = (maxv-minv)/bs+<span class="number">1</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">bucket</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            bucket[(nums[i]-minv)/bs].push_back(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> sz = bucket[i].size();</span><br><span class="line">            bucket[i] = quickSort(bucket[i]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sz; ++j) &#123;</span><br><span class="line">                nums[idx++] = bucket[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 堆排序（32 ms）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">adjust</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> p, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span>*p+<span class="number">1</span> &lt; s) &#123;</span><br><span class="line">            <span class="keyword">int</span> c1 = <span class="number">2</span>*p+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> c2 = <span class="number">2</span>*p+<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> c = (c2&lt;s &amp;&amp; nums[c2]&gt;nums[c1]) ? c2 : c1;</span><br><span class="line">            <span class="keyword">if</span> (nums[c] &gt; nums[p]) swap(nums[c], nums[p]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            p = c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">heapSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n/<span class="number">2</span><span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            adjust(nums, i, n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">            swap(nums[<span class="number">0</span>], nums[i]);</span><br><span class="line">            adjust(nums, <span class="number">0</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一道快速考察 Python 基础的面试题</title>
      <link href="/2020/02/08/%E4%B8%80%E9%81%93%E5%BF%AB%E9%80%9F%E8%80%83%E5%AF%9F%20Python%20%E5%9F%BA%E7%A1%80%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2020/02/08/%E4%B8%80%E9%81%93%E5%BF%AB%E9%80%9F%E8%80%83%E5%AF%9F%20Python%20%E5%9F%BA%E7%A1%80%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这是前一阵子群友发在群里的一道面试题，利用 Python 字典的特性，可以巧妙地使用精简代码达成完美解。</p></blockquote><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>将 data 转换成 new_data 这种形式，写出转换过程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">data = &#123;</span><br><span class="line">    <span class="string">'a_b_h'</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="string">'a_b_i'</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="string">'a_c_j'</span>:<span class="number">3</span>,</span><br><span class="line">    <span class="string">'a_d'</span>:<span class="number">4</span>,</span><br><span class="line">    <span class="string">'a_c_k'</span>:<span class="number">5</span>,</span><br><span class="line">    <span class="string">'a_e'</span>:<span class="number">6</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new_data = &#123;</span><br><span class="line">    <span class="string">'a'</span>:&#123;</span><br><span class="line">        <span class="string">'b'</span>:&#123;</span><br><span class="line">            <span class="string">'h'</span>:<span class="number">1</span>,</span><br><span class="line">            <span class="string">'i'</span>:<span class="number">2</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">'c'</span>:&#123;</span><br><span class="line">            <span class="string">'j'</span>:<span class="number">3</span>,</span><br><span class="line">            <span class="string">'k'</span>:<span class="number">5</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">'d'</span>:<span class="number">4</span>,</span><br><span class="line">        <span class="string">'e'</span>:<span class="number">6</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，转换的过程是将 key 的下划线进行拆分，然后下划线后边的字符嵌套在前面字符的值中。</p><p>感兴趣就打开 IDE，自己先试着解一下。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>你应该很快想到，主要思路是将下划线 <code>split</code> 后，然后依次使用字符生成内层字典，当达到最后一个字符时将数字作为值。</p><p>那么关键点在于，如何不断地获得内层字典去修改呢？实际本题就是考察你是否理解 Python 字典是<strong>引用传递</strong>这个特性。</p><p>什么是引用传递？我们知道 Python 中<strong>字典和列表对象都是可变对象</strong>，同一个字典对象的变量不管如何传递，只要改变其中一个变量会同步修改其他变量。这是因为变量存储的只是可变对象的引用，无论调用哪个变量，返回的依然是同一个对象。比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new_data = &#123;&#125;</span><br><span class="line">tmp = &#123;&#125;</span><br><span class="line">new_data[<span class="string">'a'</span>] = tmp</span><br><span class="line">print(new_data)  <span class="comment"># &#123;'a': &#123;&#125;&#125;</span></span><br><span class="line">tmp[<span class="string">'b'</span>] = <span class="number">1</span></span><br><span class="line">print(new_data)  <span class="comment"># &#123;'a': &#123;'b': 1&#125;&#125;</span></span><br></pre></td></tr></table></figure><p>如上，利用这个特性，将内层字典赋值给一个中间变量，然后改变这个中间变量，即可同步修改最终的 new_data 变量。</p><p>根据这个思路，初步代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">data = &#123;</span><br><span class="line">    <span class="string">'a_b_h'</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="string">'a_b_i'</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="string">'a_c_j'</span>:<span class="number">3</span>,</span><br><span class="line">    <span class="string">'a_d'</span>:<span class="number">4</span>,</span><br><span class="line">    <span class="string">'a_c_k'</span>:<span class="number">5</span>,</span><br><span class="line">    <span class="string">'a_e'</span>:<span class="number">6</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new_data = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> data.items():</span><br><span class="line">    keys = key.split(<span class="string">'_'</span>)</span><br><span class="line">    tmp = new_data</span><br><span class="line">    last = len(keys) - <span class="number">1</span>  <span class="comment"># 最后一个 key 的索引值 </span></span><br><span class="line">    <span class="keyword">for</span> i, k <span class="keyword">in</span> enumerate(keys):</span><br><span class="line">        <span class="keyword">if</span> i == last:</span><br><span class="line">            tmp[k] = value</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> k <span class="keyword">not</span> <span class="keyword">in</span> tmp:</span><br><span class="line">            sub_tmp = &#123;&#125;</span><br><span class="line">            tmp[k] = sub_tmp</span><br><span class="line">            tmp = sub_tmp</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            tmp = tmp[k]</span><br></pre></td></tr></table></figure><p>这也是群友给出的第一版答案，这样写并没有多大问题，但是代码比较繁琐，肯定还有优化空间。</p><p>我们可以只使用一个中间变量即可，进一步优化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> field, value <span class="keyword">in</span> data.items(): </span><br><span class="line">    keys = field.split(<span class="string">'_'</span>) </span><br><span class="line">    tmp = new_data </span><br><span class="line">    last = len(keys) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i, k <span class="keyword">in</span> enumerate(keys): </span><br><span class="line">        <span class="keyword">if</span> k <span class="keyword">not</span> <span class="keyword">in</span> tmp:</span><br><span class="line">            tmp[k] = &#123;&#125; <span class="keyword">if</span> i &lt; last <span class="keyword">else</span> value</span><br><span class="line">        tmp = tmp[k]  <span class="comment"># 将内层 dict 传给 tmp</span></span><br></pre></td></tr></table></figure><p>上面这个代码看似很简洁了，但是仍然还有两个 if 判断，如果不是使用了三元表达式的话，还会更多行。</p><p>所以可以进一步优化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> field, value <span class="keyword">in</span> data.items(): </span><br><span class="line">    keys = field.split(<span class="string">'_'</span>) </span><br><span class="line">    tmp = new_data </span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> keys[:<span class="number">-1</span>]: </span><br><span class="line">        tmp = tmp.setdefault(k, &#123;&#125;)</span><br><span class="line">    tmp[keys[<span class="number">-1</span>]] = value</span><br></pre></td></tr></table></figure><p>我们省略掉了 last 来判断最后一个字符的索引，直接通过 <code>keys[:-1]</code> 避开最后一个字符，末尾再单独生成数字键值对。</p><p>这里还使用字典的一个内置方法 —— <code>setdefault</code>。</p><p><code>dict.setdefault(key, default=None)</code> 方法和 <code>get</code> 方法类似，只是如果键不存在于字典中，不仅会返回 default 参数的值，还同时会用该值自动生成一个键值对。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> k <span class="keyword">not</span> <span class="keyword">in</span> tmp:</span><br><span class="line">    tmp[k] = &#123;&#125;</span><br><span class="line">v = tmp[k]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line"></span><br><span class="line">v = tmp.setdefault(k, &#123;&#125;)</span><br></pre></td></tr></table></figure><p>最终我们使用了 6 行代码就解出该题，这也是接近最简代码。</p><p>如果使用字典引用的特性是合格分的话，那么当你用出 <code>setdefault</code> 这个方法后，面试官已经给你打了优秀，因此<strong>一定要熟悉基础数据对象的所有内置方法</strong>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编写自己的 GitHub Action，体验自动化部署</title>
      <link href="/2020/01/20/%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84%20GitHub%20Action%EF%BC%8C%E4%BD%93%E9%AA%8C%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/"/>
      <url>/2020/01/20/%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84%20GitHub%20Action%EF%BC%8C%E4%BD%93%E9%AA%8C%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文将介绍如何使用 GitHub Actions 部署前端静态页面，以及如何自己创建一个 Docker 容器 Action。</p></blockquote><h2 id="简介-Actions"><a href="#简介-Actions" class="headerlink" title="简介 Actions"></a>简介 Actions</h2><p>GitHub Actions 是 GitHub 官方推出的持续集成/部署模块服务（CI/CD），和 jenkins、Travis CI 是同一类产品定位。</p><p>但 Actions 的最大优势，就是它是与 GitHub 高度整合的，只需一个配置文件即可自动开启服务。甚至你不需要购买服务器 —— GitHub Actions 自带云环境运行，包括私有仓库也可以享用，而且云环境性能也十分强劲。</p><p>当然这也意味着项目必须存放在 GitHub 才能享受这项服务。如果你的 GitHub 上有一些项目需要部署，那不妨把构建、上传等工作放到 Actions 里。比如最近我有个前端项目需要打包成静态文件，然后上传到腾讯云 COS 里，这是典型的自动化部署应用场景，我们可以借助 Actions 实现一劳永逸。</p><h2 id="配置-workflow"><a href="#配置-workflow" class="headerlink" title="配置 workflow"></a>配置 workflow</h2><p>前文说到，开启 GitHub Actions 只需一个配置文件，这个文件就是 workflow（工作流），它需要存在仓库目录下 <code>.github/workflows/*.yml</code>，文件名任意，但需要是一个 YAML 配置文件。</p><p>这个文件用来规定自动化操作在什么时候触发启动，然后需要做哪些事情，比如这样：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Deploy</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">master</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">ref:</span> <span class="string">master</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">node</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@v1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="string">"10.x"</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span> <span class="string">project</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">yarn</span> <span class="string">&amp;&amp;</span> <span class="string">yarn</span> <span class="string">build</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Upload</span> <span class="string">COS</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">zkqiang/tencent-cos-action@master</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">args:</span> <span class="string">delete</span> <span class="string">-r</span> <span class="string">-f</span> <span class="string">/</span> <span class="string">&amp;&amp;</span> <span class="string">upload</span> <span class="string">-r</span> <span class="string">./dist/</span> <span class="string">/</span></span><br><span class="line">          <span class="attr">secret_id:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.SECRET_ID</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">secret_key:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.SECRET_KEY</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">bucket:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.BUCKET</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">region:</span> <span class="string">ap-shanghai</span></span><br></pre></td></tr></table></figure><p>首先配置里所有 <code>name</code> 都是可以自定义的，只是用于可视化中进行识别。</p><p><code>on</code>: 用来指定启动触发的事件，<code>push</code> 则表示在监听到 <code>git push</code> 到指定分支时触发。如此之外还可以是 <code>pull_request</code>。</p><p><code>jobs</code>: 是工作任务，可以包含多个 job，并且每个 job 是独立的虚拟环境。不同 job 之间默认是并行的，如果想顺序执行，可以这样 <code>build-job: needs: test-job</code>。</p><p><code>runs-on</code>: 用来指定执行系统环境，不仅有常用的 Linux 发行版，还可以是 macOS 或 Windows。</p><p><code>steps</code>: 表示每个 job 需要执行的步骤，比如这里我分成了四步：拉取分支 → 安装 Node 环境 → 构建项目 → 上传 COS。</p><p><code>uses</code>: 指的是这一步骤需要先调用哪个 Action。</p><p>Action 是组成工作流最核心最基础的元素。每个 Action 可以看作封装的独立脚本，有自己的操作逻辑，我们只需要 <code>uses</code> 并通过 <code>with</code> 传入参数即可。</p><p>比如 <code>actions/checkout@v2</code> 就是官方社区贡献的用来拉取仓库分支的 Action，你不需要考虑安装 git 命令工具，只需要把分支参数传入即可。</p><p>更多 Action 你可以通过 GitHub 顶部的 Marketplace 里找到，不过问题来了，我在其中搜索腾讯 COS 并没有找到相关 Action。</p><p>腾讯官方提供了 <code>coscmd</code> 命令行工具，是基于 Python 开发，很可惜没有二进制版本。因此如果使用在 Actions 中，就必须有 Python 环境，有两种思路：</p><ol><li>在 Steps 里加入 <code>actions/setup-python</code> 这一步骤安装 Python 环境，然后再使用 <code>pip install coscmd</code>；</li><li>将上面的步骤封装成独立的 Action，之后直接 <code>uses</code> 即可。</li></ol><p>第一种很简单，可以在 steps 里加入：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">steps:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/setup-python@v1</span></span><br><span class="line">  <span class="attr">with:</span></span><br><span class="line">    <span class="attr">python-version:</span> <span class="string">'3.x'</span></span><br><span class="line">    <span class="attr">architecture:</span> <span class="string">'x64'</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">coscmd</span></span><br><span class="line">  <span class="attr">run:</span> <span class="string">pip</span> <span class="string">install</span> <span class="string">-U</span> <span class="string">coscmd</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Upload</span> <span class="string">COS</span></span><br><span class="line">  <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">    <span class="string">coscmd</span> <span class="string">config</span> <span class="string">....</span></span><br><span class="line">    <span class="string">coscmd</span> <span class="string">upload</span> <span class="string">-r</span> <span class="string">./dist/</span> <span class="string">/</span></span><br></pre></td></tr></table></figure><p>但是我选择了第二种，顺便了解如何创建自己的 Action。</p><h2 id="创建-Docker-容器-Action"><a href="#创建-Docker-容器-Action" class="headerlink" title="创建 Docker 容器 Action"></a>创建 Docker 容器 Action</h2><p>官方提供了两种方式创建 Action，一种是使用 JavaScript 环境创建，另一种是通过 Docker 容器创建。<code>coscmd</code> 既然依赖 Python，这里使用 Docker 容器更简单一些。</p><h3 id="创建-Dockerfile"><a href="#创建-Dockerfile" class="headerlink" title="创建 Dockerfile"></a>创建 Dockerfile</h3><p>那我们首先创建一个 Dockerfile:</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.7</span>-slim</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> PYTHONDONTWRITEBYTECODE <span class="number">1</span></span><br><span class="line"><span class="keyword">ENV</span> PYTHONUNBUFFERED <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip install --upgrade --no-cache-dir coscmd</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> <span class="string">"entrypoint.sh"</span> <span class="string">"/entrypoint.sh"</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> chmod +x /entrypoint.sh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"/entrypoint.sh"</span>]</span></span><br></pre></td></tr></table></figure><p>如果不了解 Docker 也没关系，只需要知道 <code>FROM</code> 是指定容器环境，然后 <code>RUN</code> 去执行 <code>pip install coscmd</code> 的操作。最后将仓库目录下的 <code>entrypoint.sh</code> 拷贝到容器中，并用 <code>ENTRYPOINT</code> 执行，至于这个 sh 文件后面再说 。</p><h3 id="创建-action-yml"><a href="#创建-action-yml" class="headerlink" title="创建 action.yml"></a>创建 action.yml</h3><p>这里定义了 Action 相关的配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">'Tencent COS Action'</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">'GitHub Action for Tencent COS Command'</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">'zkqiang &lt;zkqiang@126.com&gt;'</span></span><br><span class="line"><span class="attr">branding:</span></span><br><span class="line">  <span class="attr">icon:</span> <span class="string">'cloud'</span></span><br><span class="line">  <span class="attr">color:</span> <span class="string">'blue'</span></span><br><span class="line"><span class="attr">inputs:</span></span><br><span class="line">  <span class="attr">args:</span></span><br><span class="line">    <span class="attr">description:</span> <span class="string">'COSCMD args'</span></span><br><span class="line">    <span class="attr">required:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">secret_id:</span></span><br><span class="line">    <span class="attr">description:</span> <span class="string">'Tencent cloud SecretId'</span></span><br><span class="line">    <span class="attr">required:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">secret_key:</span></span><br><span class="line">    <span class="attr">description:</span> <span class="string">'Tencent cloud SecretKey'</span></span><br><span class="line">    <span class="attr">required:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">bucket:</span></span><br><span class="line">    <span class="attr">description:</span> <span class="string">'COS bucket name'</span></span><br><span class="line">    <span class="attr">required:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">region:</span></span><br><span class="line">    <span class="attr">description:</span> <span class="string">'COS bucket region'</span></span><br><span class="line">    <span class="attr">required:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">runs:</span></span><br><span class="line">  <span class="attr">using:</span> <span class="string">'docker'</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">'Dockerfile'</span></span><br></pre></td></tr></table></figure><p>除了一些描述性信息，最重要的是定义 <code>input: args</code> 输入参数，也就是 step 里 <code>with</code> 传递的参数，可以通过 <code>required</code> 设置该参数是否必传。这里传递的参数都是识别和验证对象桶的必需参数。</p><p>最后通过 <code>runs</code> 指定 docker 环境和 <code>Dockerfile</code> 文件。</p><h3 id="创建-entrypoint-sh"><a href="#创建-entrypoint-sh" class="headerlink" title="创建 entrypoint.sh"></a>创建 entrypoint.sh</h3><p>这里需要使用 shell 来写传递参数后的执行逻辑，由于 <code>coscmd</code> 本身就是命令行工具，所以我们只需将参数再传给它即可。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$INPUT_ARGS</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">'Required Args parameter'</span></span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ...省略部分代码</span></span><br><span class="line"></span><br><span class="line">coscmd config -a <span class="variable">$INPUT_SECRET_ID</span> -s <span class="variable">$INPUT_SECRET_KEY</span> -b <span class="variable">$INPUT_BUCKET</span> -r <span class="variable">$INPUT_REGION</span> -m <span class="variable">$THREAD</span></span><br><span class="line"></span><br><span class="line">IFS=<span class="string">"&amp;&amp;"</span></span><br><span class="line">arrARGS=(<span class="variable">$INPUT_ARGS</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> each <span class="keyword">in</span> <span class="variable">$&#123;arrARGS[@]&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">unset</span> IFS</span><br><span class="line">  each=$(<span class="built_in">echo</span> <span class="variable">$&#123;each&#125;</span> | xargs)</span><br><span class="line">  <span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$each</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Running command: coscmd <span class="variable">$&#123;each&#125;</span>"</span></span><br><span class="line">  coscmd <span class="variable">$each</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p><code>action.yml</code> 中的参数会自动转成 <code>INPUT_</code> 前缀并且大写的变量传入，因此我们可以直接引用。</p><p>验证完参数之后（也可省略，<code>action.yml</code> 已判断），先配置 <code>coscmd config</code>，然后将 args 参数传入 <code>coscmd</code> 即可。另外为了方便使用多条命令，加入了支持 <code>&amp;&amp;</code> 连接命令，脚本里需要对其分割。</p><h2 id="调用自建的-Action"><a href="#调用自建的-Action" class="headerlink" title="调用自建的 Action"></a>调用自建的 Action</h2><p>将刚才创建的 Action 推送到 GitHub 上，就调用这个 Action  了，前文的 workflow 配置里也已经包含了：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Upload</span> <span class="string">COS</span></span><br><span class="line"><span class="attr">uses:</span> <span class="string">zkqiang/tencent-cos-action@master</span></span><br><span class="line"><span class="attr">with:</span></span><br><span class="line">  <span class="attr">args:</span> <span class="string">delete</span> <span class="string">-r</span> <span class="string">/</span> <span class="string">&amp;&amp;</span> <span class="string">upload</span> <span class="string">-r</span> <span class="string">./dist/</span> <span class="string">/</span></span><br><span class="line">  <span class="attr">secretId:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.SECRET_ID</span> <span class="string">&#125;&#125;</span></span><br><span class="line">  <span class="attr">secretKey:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.SECRET_KEY</span> <span class="string">&#125;&#125;</span></span><br><span class="line">  <span class="attr">bucket:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.BUCKET</span> <span class="string">&#125;&#125;</span></span><br><span class="line">  <span class="attr">region:</span> <span class="string">ap-shanghai</span></span><br></pre></td></tr></table></figure><p><code>args: delete -r -f / &amp;&amp; upload -r ./dist/ /</code>，相当于先清空对象桶，然后再执行上传。<code>delete</code> 和 <code>upload</code> 都是 <code>coscmd</code> 自己的命令参数，其他命令可以查阅官方文档。</p><p>另外有没有注意到 <code>$</code> 这种参数，并不是具体的值，而是调用了 GitHub Settings 里保存的 secrets，添加方式如下：</p><p><img src="https://static.zkqiang.cn/images/20200118171056.png-slim" alt="设置 secrets 的步骤"></p><p>为什么这样做？是因为 workflow 代码在公开仓库中也是任意可见的，如果将 SecretKey 这些信息暴露，等于将 COS 操作权限交出，而存在 settings 里则不会有这个问题。</p><p>然后就可以使用 Actions 功能了，向包含 workflow 的仓库 master 分支推送一次代码，如果没有配错的话，过段时间可以在 Actions 栏里看到一列绿色的对号。 </p><p><img src="https://static.zkqiang.cn/images/20200119104057.png-slim" alt="Actions 执行结果"></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>至此我们了解了如何使用 GitHub Actions 部署，以及如何自己创建一个 Action，可见这一项免费的服务真的非常好用，借助 Action 开源市场也可以大幅简化使用。</p><p>当然 CI 的应用不仅仅在部署这方面，绝大部分从开发完成到交付/部署之间的动作也都可以用自动化完成，只要是重复的操作就应该考虑能不能加入自动化来解放双手。</p><p>本文 COS Action 的<a href="https://github.com/zkqiang/tencent-cos-action" target="_blank" rel="noopener">代码仓库</a>。</p><p><a href="https://help.github.com/cn/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#" target="_blank" rel="noopener">workflow 官方文档</a></p><p>更多的 Actions 可以从 <a href="https://github.com/marketplace" target="_blank" rel="noopener">Marketplace</a> 和 <a href="https://github.com/sdras/awesome-actions" target="_blank" rel="noopener">awesome-actions</a> 里获取。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 开源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 2 与 3 共存了 11 年，新年就要和它道别</title>
      <link href="/2019/12/31/Python%202%20%E4%B8%8E%203%20%E5%85%B1%E5%AD%98%E4%BA%86%2011%20%E5%B9%B4%EF%BC%8C%E6%96%B0%E5%B9%B4%E5%B0%B1%E8%A6%81%E5%92%8C%E5%AE%83%E9%81%93%E5%88%AB/"/>
      <url>/2019/12/31/Python%202%20%E4%B8%8E%203%20%E5%85%B1%E5%AD%98%E4%BA%86%2011%20%E5%B9%B4%EF%BC%8C%E6%96%B0%E5%B9%B4%E5%B0%B1%E8%A6%81%E5%92%8C%E5%AE%83%E9%81%93%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在 Python 3.9 都已经进入 dev 版本的 2020 年，Python 2 终于要和我们告别了。</p></blockquote><h2 id="2-and-3"><a href="#2-and-3" class="headerlink" title="2 and 3"></a>2 and 3</h2><p>Python 2 第一个版本发布于 2000 年 10 月 16 日，到今年正好是第 20 个年头。而 Python 3 发布于 2008 年 12 月 3 日，但由于 3.0 版本在底层进行了大量重构（主要是 Unicode 与 C API 的改动），无法完整兼容 Python 2，因此官方并没有停止对 Python 2 的维护。</p><p>从此 2 与 3 依然都在发布新版本，官方想通过平滑的方式过渡到新版本。然而并不是所有的社区贡献者有这种精力去同时维护两个版本，许多开源库它们至今都停更在 2.X 版本。</p><p>两版本共存的日子，一晃就是 11 年。</p><h2 id="2-to-3"><a href="#2-to-3" class="headerlink" title="2 to 3"></a>2 to 3</h2><p>好在 Python 3 更新了越来越多独有的特性与性能优化，加上社区的不断努力推动，在近几年爆发增长的初学者当中，大部分都被推荐使用了 3.X 版本作为入门版本，3 版本在近几年才占据了主导。</p><p><img src="https://static.zkqiang.cn/images/20191231124049.jpg-slim" alt="两版本使用比例趋势"></p><p>终于 Python 核心开发团队对外宣布，将在 2020 年逐步停止对 Python 2 的支持，但并没有给出具体时间。</p><p>2017 年 NumPy 正式宣布将在 2019 年 1 月 1 日停止支持 Python 2。之后 pandas 与 Jupyter notebook 等开发团队纷纷宣布即将停止支持 2.X 版本。</p><p>2018 年 Python 创始人 Guido van Rossum 在官方邮件组表示，他们将于 2020 年 1 月 1 日停止对 Python 2.7 的支持，这也是 2.X 最后一个版本。</p><p><img src="https://static.zkqiang.cn/images/20191231132215.jpeg-slim" alt="Guido 邮件截图"></p><p>他在邮件写道：</p><blockquote><p>不要玩文字游戏了！Python 2.7 的 EOL（停用）日期是 2020 年 1 月 1 日，接下来，将不会有任何更新，也不会再有源码安全补丁。在此日期之后，Python 核心开发者、PSF 和 python.org 将不会提供任何支持。如果你还想获得支持，那得付相关商业费用。当然，它是开源的，所以我们也欢迎大家 fork。<br>我们最初决定 2015 年为 EOL 日期，然后推迟到 2020 年，给大家的时间已经很充足了，核心开发者也辛苦太久了。此外，坦诚地说，我并不觉得停用 Python 2.7 是件坏事。</p></blockquote><h2 id="After-3"><a href="#After-3" class="headerlink" title="After 3"></a>After 3</h2><p>不过停止更新并不会有多大的影响，因为根据 JetBrains 最新的 Python 开发者报告显示，近九成的开发者已经使用 Python 3 版本。</p><p><img src="https://static.zkqiang.cn/images/20191231124050.png-slim" alt="JetBrains 开发者报告"></p><p>相信在 2020 年使用 Python 2 的开发者将低于 5%。</p><p>如果你有代码想迁移 Python 3，别忘了尝试使用官方提供的 <a href="https://docs.python.org/3/howto/pyporting.html" target="_blank" rel="noopener">2to3</a> 迁移工具。</p><p>另外 3.9 版本已经有 dev 版本了，留给 Python 3 的版本号也到头了（除非使用两位数），后续 Python 怎么走，咱们拭目以待。 </p><p>最后祝各位读者新年快乐！</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>30 年前的圣诞节，Python 序章被谱写</title>
      <link href="/2019/12/24/30%20%E5%B9%B4%E5%89%8D%E7%9A%84%E5%9C%A3%E8%AF%9E%E8%8A%82%EF%BC%8CPython%20%E5%BA%8F%E7%AB%A0%E8%A2%AB%E8%B0%B1%E5%86%99/"/>
      <url>/2019/12/24/30%20%E5%B9%B4%E5%89%8D%E7%9A%84%E5%9C%A3%E8%AF%9E%E8%8A%82%EF%BC%8CPython%20%E5%BA%8F%E7%AB%A0%E8%A2%AB%E8%B0%B1%E5%86%99/</url>
      
        <content type="html"><![CDATA[<p>1989 年圣诞节期间，已经从阿姆斯特丹大学（University of Amsterdam）获得数学和计算机硕士学位的 Guido van Rossum，为了打发圣诞节的无趣，决心开发一个新语言解释器，作为 ABC 语言的一种继承，这个语言就是当下最流行的语言之一 —— Python。</p><p><img src="https://static.zkqiang.cn/images/20191224180736.png-slim" alt="Guido 本人照片"></p><p>之所以选中 Python（蟒蛇）作为该编程语言的名字，是取自英国 20世纪 70 年代首播的电视喜剧《蒙提.派森的飞行马戏团》（Monty Python’s Flying Circus）。</p><p><img src="https://static.zkqiang.cn/images/20191224185859.png-slim" alt="Python 命名源于此剧"></p><p>1991年，第一个 Python 解释器正式发布。它是用 C 语言实现，能够调用 C 库(.so文件)。并且当时已经具有Python 的核心数据类型：类(class)、函数(function)、列表(list)、字典(dict)，以及模块(module)。</p><p><img src="https://static.zkqiang.cn/images/20191224182054.jpg-slim" alt="Python 经典的数据类型"></p><p>Python 设计哲学是“优雅”、“明确”、“简单”，Guido 将“人生苦短，我用 Python” (Life is short, use python) 作为 Python 的 Slogan。</p><p>这是因为 Python 将许多机器层面上的细节隐藏，交给编译器处理，并凸显出逻辑层面的编程思。这让 Python 程序员可以花更多的时间用于思考程序的逻辑，而不是具体的实现细节。</p><p><img src="https://static.zkqiang.cn/images/20191224182658.jpg-slim" alt="人生苦短，我用 Python"></p><p>正因如此，Python 在冷门多年后，终于借助大数据与人工智能的兴起而迅速蹿红，不需要注重编程工程性的特点使数据/AI 开发者得心应手。</p><p>如今 Python 已经成为世界最热门的语言之一，据 Jetbrains 调查显示，27% 受访对象在过去一年中开始或仍在持续学习 Python。</p><p><img src="https://static.zkqiang.cn/images/20191224182909.png-slim" alt="TIOBE 上 Python 的趋势"></p><p>越来越多的数据开发者使用 Python 代替 MATLAB 作为数据处理语言，机器学习开发者将 Python 几乎首选语言。而 Flask 与 Django 这两款继承 Python 设计哲学、优秀的 Web 框架，也让 Python 在 Web 领域占领一席之地。</p><p><img src="https://static.zkqiang.cn/images/20191224183628.png-slim" alt="Jetbrains 年度调查"></p><p>各大互联网企业也争相拥抱 Python，Google 不仅聘请过 Guido，还把 Python 作为 Google 第三大开发语言，YouTube 与 Instagram 则将 Python 作为主力技术栈，国内的豆瓣也是 Python 的忠实使用方。</p><p>不知 Guido 在 30 年前的那个圣诞，是否会想到写出了一个假期闲作，在 30 年后竟然成为一门雄霸一方的编程语言。</p><p>各位圣诞节快乐！</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文言文编程火了，可我完全学不懂</title>
      <link href="/2019/12/21/%E6%96%87%E8%A8%80%E6%96%87%E7%BC%96%E7%A8%8B%E7%81%AB%E4%BA%86%EF%BC%8C%E5%8F%AF%E6%88%91%E5%AE%8C%E5%85%A8%E5%AD%A6%E4%B8%8D%E6%87%82/"/>
      <url>/2019/12/21/%E6%96%87%E8%A8%80%E6%96%87%E7%BC%96%E7%A8%8B%E7%81%AB%E4%BA%86%EF%BC%8C%E5%8F%AF%E6%88%91%E5%AE%8C%E5%85%A8%E5%AD%A6%E4%B8%8D%E6%87%82/</url>
      
        <content type="html"><![CDATA[<blockquote><p>毕竟有易语言在前，有人认为中文可以降低国人学习编程的门槛，也增强汉语的国际地位。然而最近大火的文言文编程语言，让你明白什么叫“中文比英语还难”。</p></blockquote><p><img src="https://static.zkqiang.cn/images/20191219213432.png-slim" alt=""></p><h2 id="Hello-wenyan"><a href="#Hello-wenyan" class="headerlink" title="Hello wenyan"></a>Hello wenyan</h2><p>最近有个 GitHub 项目火了 —— 文言编程语言 / wenyan-lang。</p><p>现在这个项目已经超过 10K Stars 了（昨天看还是 9K，一夜涨了 1K），咱赶紧来研究下。</p><p>学语言嘛，当然先从 “Hello world” 开始，看看文言版怎么写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">吾有一數。曰三。名之曰「甲」。</span><br><span class="line">為是「甲」遍。</span><br><span class="line">吾有一言。曰「「問天地好在。」」。書之。</span><br><span class="line">云云。</span><br></pre></td></tr></table></figure><p>没看懂，编译成 JavaScript：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"問天地好在。"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">問天地好在。</span><br><span class="line">問天地好在。</span><br><span class="line">問天地好在。</span><br></pre></td></tr></table></figure><p>完全的中文编程有木有，使用古汉语语法，具有图灵完整性，可以编译成 JavaScript 或 Python。</p><p>如同古人篆书一般，一顿之乎者也，程序写好了！</p><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><p>赶紧学起来，第一章变量走起，中文编程肯定不能用 abc，还好我们有甲乙丙：</p><table><thead><tr><th>wenyan</th><th>JavaScript</th></tr></thead><tbody><tr><td><code>吾有一數。曰三。名之曰「甲」。</code></td><td><code>var a = 3;</code></td></tr><tr><td><code>有數五十。名之曰「大衍」。</code></td><td><code>var dayan = 50;</code></td></tr><tr><td><code>吾有一言。曰「「噫吁戲」」。名之曰「乙」。</code></td><td><code>var b = &quot;alas!&quot;;</code></td></tr></tbody></table><p>true/false 我们也有对应的 陽/陰（繁体的阳/阴），类型就称为“爻”（卦符的基本符号）：</p><table><thead><tr><th>wenyan</th><th>JavaScript</th></tr></thead><tbody><tr><td><code>吾有一爻。曰陰。名之曰「丙」。</code></td><td><code>var c = false;</code></td></tr></tbody></table><p>if 判断也没问题：</p><table><thead><tr><th>wenyan</th><th>JavaScript</th></tr></thead><tbody><tr><td><code>若三不大於五者。乃得「「想當然耳」」。若非。乃得「「怪哉」」也。</code></td><td><code>if(3&lt;=5){return &quot;of course&quot;}else{return &quot;no way&quot;}</code></td></tr></tbody></table><p>循环更为简洁，直接声明次数，最后以云云结尾：</p><table><thead><tr><th>wenyan</th><th>JavaScript</th></tr></thead><tbody><tr><td><code>為是百遍。⋯⋯ 云云。</code></td><td><code>for (var i = 0; i &lt; 100; i++){ ... }</code></td></tr><tr><td><code>恆為是。⋯⋯ 云云。</code></td><td><code>while (true) { ... }</code></td></tr><tr><td><code>乃止。</code></td><td><code>break;</code></td></tr></tbody></table><p>加减乘除一应俱全，连逻辑运算符都支持：</p><table><thead><tr><th>wenyan</th><th>JavaScript</th></tr></thead><tbody><tr><td><code>加一以二。乘其以三。</code></td><td><code>(1+2)*3</code></td></tr><tr><td><code>除十以三。所餘幾何。</code></td><td><code>10%3</code></td></tr><tr><td><code>減七百五十六以四百三十三。名之曰「甲」。</code></td><td><code>var a = 756-433;</code></td></tr><tr><td><code>夫「甲」「乙」中有陽乎。</code></td><td>`a</td></tr></tbody></table><p>容器类型也支持，而且尊重汉语习惯，首个下标是从一开始：</p><table><thead><tr><th>wenyan</th><th>JavaScript</th></tr></thead><tbody><tr><td><code>吾有一列。名之曰「甲」。充「甲」以四。以二。</code></td><td><code>var a = []; a.push(4, 2);</code></td></tr><tr><td><code>夫「寶劍」之長。</code></td><td><code>sword.length;</code></td></tr><tr><td><code>夫「甲」之一。</code></td><td><code>a[0]</code></td></tr><tr><td><code>夫「玫瑰」之「「名」」。</code></td><td><code>rose[&quot;name&quot;]</code></td></tr></tbody></table><p>下面是进阶语法了，<del>定义一个函数</del> 吾有一術：</p><table><thead><tr><th>wenyan</th><th>JavaScript</th></tr></thead><tbody><tr><td><code>吾有一術。名之曰「吸星大法」。是術曰。⋯⋯是謂「吸星大法」之術也。</code></td><td><code>function f(){...}</code></td></tr><tr><td><code>吾有一術。名之曰「六脈神劍」。欲行是術。必先得六數。曰「甲」。曰「乙」。曰「丙」。曰「丁」。曰「戊」。曰「己」乃行是術曰。⋯⋯是謂「六脈神劍」之術也。</code></td><td><code>function f(a,b,c,d,e,f){...}</code></td></tr><tr><td><code>吾有一術。名之曰「翻倍」。欲行是術。必先得一數。曰「甲」。乃行是術曰。乘「甲」以二。名之曰「乙」。乃得「乙」。是謂「翻倍」之術也。</code></td><td><code>function double(a){var b = a * 2; return b;}</code></td></tr><tr><td><code>施「翻倍」於「大衍」。</code></td><td><code>double(dayan);</code></td></tr><tr><td><code>吾有一數。曰五。書之。</code></td><td><code>console.log(5);</code></td></tr></tbody></table><h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><p>作者提供了经典程序题目的文言版代码，比如埃拉托斯特尼筛法、 快速排序、曼德博集合、汉诺塔。</p><p>另外作者还提供了在线 IDE，可以直接编译执行代码。</p><h4 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h4><p><img src="https://static.zkqiang.cn/images/20191220133312.png-slim" alt="点击查看大图"></p><h4 id="曼德博集合"><a href="#曼德博集合" class="headerlink" title="曼德博集合"></a>曼德博集合</h4><p><img src="https://static.zkqiang.cn/images/20191220134039.png-slim" alt="点击查看大图"></p><p>看完这些代码让我感觉：</p><p>《九章算术》就是一本算法导论；</p><p>《孙子兵法》就是一本安全攻防；</p><p>《易经》大概是一本二进制逆向吧…</p><h2 id="一些题外话"><a href="#一些题外话" class="headerlink" title="一些题外话"></a>一些题外话</h2><p>该项目的作者名叫 Huang Lingdong，卡内基梅隆大学（CMU）计算机专业大四学生。这么一位世界顶级高校的大佬，做这个项目其实只是一个期末作业亦或业余爱好。</p><p>点进 issues，广大中国编程爱好者也表达了对作者的敬佩：</p><p><img src="https://static.zkqiang.cn/images/20191220143545.png-slim" alt=""></p><p>然而当我也惊叹这个项目的脑洞和创意时，在 issues 里还是看到了一些令我非常不悦的话题：</p><p><img src="https://static.zkqiang.cn/images/20191220143753.png-slim" alt=""></p><p>这位兄弟的脑洞看来比作者还大…</p><p>不然怎么把一个编程语言联系到风投…</p><p><img src="https://static.zkqiang.cn/images/20191220143751.png-slim" alt=""></p><p>这位兄弟前半句是对的，但后半句似乎有一些鄙夷和不屑？</p><p>我在下边回复给他一个表情：</p><p><img src="https://static.zkqiang.cn/images/20191220144408.jpg-slim" alt=""></p><p>当然哪里都少不了“意义党”：</p><p><img src="https://static.zkqiang.cn/images/20191220144549.png-slim" alt=""></p><p>真是哪里都有上纲上线的人，作者自娱自乐写了一个开源项目，为此查阅大量古汉语资料，也不图什么名利，就获得几千 Stars，就成为了某些人嘴里的恰烂钱、无意义、垃圾项目。</p><p><strong>而当我点开这些人的头像时，发现他们挂着都是一些 Fork 和不明所以的 Repo，我也不知道他们挂这些的意义是什么…</strong></p><p>我当然也从源码看出，这个项目可能叫“解释器”更贴切一些，但作者也从来没说这是一个多么认真、能用于生产环境的正式项目。</p><h2 id="Esolang"><a href="#Esolang" class="headerlink" title="Esolang"></a>Esolang</h2><p>如果你和上面的他们有类似的想法，那么我给你普及一个编程名词：</p><p><strong>Esoteric programming language</strong>，简称 Esolang，它们的设计被用于测试计算机语言设计的极限，作为一个概念的证明，或仅仅是一个玩笑。Esolang 创作者通常并不打算让它成为主流编程语言，他们几乎不会在意语言的可用性，甚至恰恰相反，会故意增加使用难度。</p><p>比如 Brainfuck，它是在 1993 年被创造的编程语言，语法仅包含八种符号，没有任何单词，用它打印 Hello world 是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">++++++++++[&gt;+++++++&gt;++++++++++&gt;+++&gt;+&lt;&lt;&lt;&lt;-]</span><br><span class="line">&gt;++.&gt;+.+++++++..+++.&gt;++.&lt;&lt;+++++++++++++++.</span><br><span class="line">&gt;.+++.------.--------.&gt;+.&gt;.</span><br></pre></td></tr></table></figure><p>再比如 MarioLANG，它同样只能使用符号，需要使用形似马里奥关卡的语法来书写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">++++:       &gt;       &gt;  +:+:+:+:+:+:+:::::</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;+      &gt;^&#x3D;&#x3D;&#x3D;    &quot;&quot;&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">    +:-):(:^&#x3D;   &#x3D;                       !</span><br><span class="line">    &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;    &#x3D;                      #</span><br><span class="line">                  &#x3D; !             .+.,:-&lt;</span><br><span class="line">                   &#x3D;###           &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;</span><br></pre></td></tr></table></figure><p>Parenthesis Hell，言如其名，括号地狱，只能使用括号来书写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(()()(()()(()()()()((()()(()(()((()((()()()((()((()()()((()((((()()(()(</span><br><span class="line">)()()()()(((()(((()((()((((()(((()()(()()((()((()()()((()()(()()()()(()</span><br><span class="line">()()()(()()()()(()(())))))))))))))))))))))))))))))))))))))))))))))))))</span><br></pre></td></tr></table></figure><p>所以 wenyan-lang 实际也属于 Esolang，并不是用于生产的语言，你在这些语言中寻找意义，我觉得你这种行为就挺没意义的…</p><p>wenyan-lang GitHub: <a href="https://github.com/LingDong-/wenyan-lang" target="_blank" rel="noopener">https://github.com/LingDong-/wenyan-lang</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 开源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过 Python 理解 Mixin 概念</title>
      <link href="/2019/12/07/%E9%80%9A%E8%BF%87%20Python%20%E7%90%86%E8%A7%A3%20Mixin%20%E6%A6%82%E5%BF%B5/"/>
      <url>/2019/12/07/%E9%80%9A%E8%BF%87%20Python%20%E7%90%86%E8%A7%A3%20Mixin%20%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="Mixin-的概念"><a href="#Mixin-的概念" class="headerlink" title="Mixin 的概念"></a>Mixin 的概念</h2><p>Mixin 即 <code>Mix-in</code>，常被译为“混入”，是一种编程模式，在 Python 等面向对象语言中，通常它是实现了某种功能单元的类，用于被其他子类继承，将功能组合到子类中。</p><p>利用 Python 的多重继承，子类可以继承不同功能的 Mixin 类，按需动态组合使用。</p><p>当多个类都实现了同一种功能时，这时应该考虑将该功能抽离成 Mixin 类。</p><h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><p>定义一个简单的类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, gender, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.gender = gender</span><br><span class="line">        self.age = age</span><br></pre></td></tr></table></figure><p>我们可以通过调用实例属性的方式来访问：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = Person(<span class="string">"小陈"</span>, <span class="string">"男"</span>, <span class="number">18</span>)</span><br><span class="line">print(p.name)  <span class="comment"># "小陈"</span></span><br></pre></td></tr></table></figure><p>然后我们定义一个 Mixin 类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MappingMixin</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__dict__.get(key)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__dict__.set(key, value)</span><br></pre></td></tr></table></figure><p>这个类可以让子类拥有像 dict 一样调用属性的功能</p><p>我们将这个 Mixin 加入到 Person 类中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(MappingMixin)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, gender, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.gender = gender</span><br><span class="line">        self.age = age</span><br></pre></td></tr></table></figure><p>现在 Person 拥有另一种调用属性方式了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p = Person(<span class="string">"小陈"</span>, <span class="string">"男"</span>, <span class="number">18</span>)</span><br><span class="line">print(p[<span class="string">'name'</span>])  <span class="comment"># "小陈"</span></span><br><span class="line">print(p[<span class="string">'age'</span>])  <span class="comment"># 18</span></span><br></pre></td></tr></table></figure><p>再定义一个 Mixin 类，这个类实现了 <code>__repr__</code> 方法，能自动将属性与值拼接成字符串：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReprMixin</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        s = self.__class__.__name__ + <span class="string">'('</span></span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> self.__dict__.items():</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> k.startswith(<span class="string">'_'</span>):</span><br><span class="line">                s += <span class="string">'&#123;&#125;=&#123;&#125;, '</span>.format(k, v)</span><br><span class="line">        s = s.rstrip(<span class="string">', '</span>) + <span class="string">')'</span>  <span class="comment"># 将最后一个逗号和空格换成括号</span></span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure><p>利用 Python 的特性，一个类可以继承多个父类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(MappingMixin, ReprMixin)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, gender, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.gender = gender</span><br><span class="line">        self.age = age</span><br></pre></td></tr></table></figure><p>这样这个子类混入了两种功能：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p = Person(<span class="string">"小陈"</span>, <span class="string">"男"</span>, <span class="number">18</span>)</span><br><span class="line">print(p[<span class="string">'name'</span>])  <span class="comment"># "小陈"</span></span><br><span class="line">print(p)  <span class="comment"># Person(name=小陈, gender=男, age=18)</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Mixin 实质上是利用语言特性，可以把它看作一种特殊的多重继承，所以它并不是 Python 独享，只要支持多重继承或者类似特性的都可以使用，比如 Ruby 中 include 语法，Vue 等前端领域也有 Mixin 的概念。</p><p>但 Mixin 终归不属于语言的语法，为了代码的可读性和可维护性，定义和使用 Mixin 类应该遵循几个原则：</p><ol><li>Mixin 实现的功能需要是通用的，并且是单一的，比如上例中两个 Mixin 类都适用于大部分子类，每个 Mixin 只实现一种功能，可按需继承。</li><li>Mixin 只用于拓展子类的功能，不能影响子类的主要功能，子类也不能依赖 Mixin。比如上例中 <code>Person</code> 继承不同的 Mixin 只是增加了一些功能，并不影响自身的主要功能。如果是依赖关系，则是真正的基类，不应该用 Mixin 命名。</li><li>Mixin 类自身不能进行实例化，仅用于被子类继承。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub 发布了官方 App，还打算冰封你的代码一千年</title>
      <link href="/2019/11/14/GitHub%20%E5%8F%91%E5%B8%83%E4%BA%86%E5%AE%98%E6%96%B9%20App%EF%BC%8C%E8%BF%98%E6%89%93%E7%AE%97%E5%86%B0%E5%B0%81%E4%BD%A0%E7%9A%84%E4%BB%A3%E7%A0%81%E4%B8%80%E5%8D%83%E5%B9%B4/"/>
      <url>/2019/11/14/GitHub%20%E5%8F%91%E5%B8%83%E4%BA%86%E5%AE%98%E6%96%B9%20App%EF%BC%8C%E8%BF%98%E6%89%93%E7%AE%97%E5%86%B0%E5%B0%81%E4%BD%A0%E7%9A%84%E4%BB%A3%E7%A0%81%E4%B8%80%E5%8D%83%E5%B9%B4/</url>
      
        <content type="html"><![CDATA[<blockquote><p>11 月 13 日，GitHub Universe 2019 开发者大会上，公布了大量新功能，包括发布 GitHub 移动版、GitHub Actions 和 Packages 正式版上市、重新设计了通知体验，以及宣布建设一个数据仓库存储所有公共仓库一千年…</p></blockquote><h2 id="GitHub-App"><a href="#GitHub-App" class="headerlink" title="GitHub App"></a>GitHub App</h2><p>官方 App 终于来了，在手机上就可以 Review 代码、处理 Issues、合并 PR 等常用操作。让你无论身处何处，都可以灵活地推进工作并与团队保持联系（加班）。</p><p><img src="http://static.zkqiang.cn/images/20191114154520.png-slim" alt=""></p><p><img src="http://static.zkqiang.cn/images/20191114154522.png-slim" alt=""></p><p>目前已经发布 iOS beta 版并上线 TestFlight，连黑暗模式都安排上了。</p><p><a href="https://github.com/mobile" target="_blank" rel="noopener">测试申请链接</a></p><p>Android 版还要等段时间推出。</p><h2 id="Actions-和-Packages-正式版"><a href="#Actions-和-Packages-正式版" class="headerlink" title="Actions 和 Packages 正式版"></a>Actions 和 Packages 正式版</h2><p>去年 Universe 大会上发布的 GitHub Actions，以及今年上半年发布的 GitHub Packages 结束了测试期。</p><p>GitHub Actions 是仓库自带的自动化构建与部署功能，拥有完整的 CI/CD 解决方案和本机软件包管理，并且 GitHub Marketplace 上也提供有上千款社区开发的工作流可以使用。</p><p><img src="http://static.zkqiang.cn/images/20191114160332.png-slim" alt="GitHub Actions"></p><p>GitHub Packages 是官方推出的包管理功能，实现将源代码和包在一个地方集成权限管理和统计，托管在 GitHub 上的软件包，不仅包括详细信息和下载统计信息，而且还有它们的全部历史记录。</p><p><img src="http://static.zkqiang.cn/images/20191114160649.png-slim" alt="GitHub Packages"></p><p>现在这两款功能免费向所有公共仓库开放，并且可以使用 Actions 将新的软件包版本自动发布到 GitHub Packages，使用 Actions 触发软件包安装，以及以最小的配置安装托管在 GitHub Packages 或首选记录注册表上的软件包和映像。通过 Actions 使用相同的 GITHUB_TOKEN 进行所有自动化程序包的上载和下载。</p><h2 id="通知功能"><a href="#通知功能" class="headerlink" title="通知功能"></a>通知功能</h2><p>以往在一些热门开源项目中、或者大型团队中，各种 Issues 和 PR 的通知邮件会无差别充斥在邮箱中，很难将信号和噪音区分开。</p><p>官方终于推出了通知功能来解决这个问题，设立了通知收件箱，可以对不同信息进行筛选和分类，让你聚焦到有价值的信息中。</p><p><img src="http://static.zkqiang.cn/images/20191114160945.gif-slim" alt=""></p><p>并且会着重结合官方 App 进行通知推送。</p><p>目前该功能是内测阶段，如果想体验可以下载 GitHub App 获取测试资格。</p><h2 id="代码导航"><a href="#代码导航" class="headerlink" title="代码导航"></a>代码导航</h2><p>代码导航已于今年早些时候在特定存储库的有限公测中发布。今天，官方将其提供给 GitHub 上的所有 Ruby，Python 和 Go 存储库，并且很快就会有更多的语言。查看任何公共或私有存储库上的 “code” 选项卡，以获取受支持的语言以进行尝试。</p><p><img src="http://static.zkqiang.cn/images/20191114161903.png-slim" alt=""></p><h2 id="代码搜索"><a href="#代码搜索" class="headerlink" title="代码搜索"></a>代码搜索</h2><p>在接下来的几个月中，官方将引入一种新的代码搜索体验，包括区分大小写，特殊字符，标记化和其他特定于代码的搜索条件。</p><p><img src="http://static.zkqiang.cn/images/20191114162100.png-slim" alt=""></p><h2 id="保存你的代码一千年"><a href="#保存你的代码一千年" class="headerlink" title="保存你的代码一千年"></a>保存你的代码一千年</h2><p>官方发布了一项伟大的计划：将建设一个名为 GitHub Arctic Code Vault 的数据存储库，存储在北极世界档案馆（AWA）中，这是一个长期的档案设施，位于北极山永久冻土层深 250 米。</p><p>GitHub 将在 2020 年 2 月 2 日扫描所有活动公共存储库的快照，并将这些数据保存在 Arctic Code Vault 中。</p><p><img src="http://static.zkqiang.cn/images/20191114163126.png-slim" alt=""></p><p>官方博客这样写道：</p><blockquote><p>我们与斯坦福图书馆，Long Now 基金会，Internet 档案馆，软件遗产基金会，Piql，Microsoft Research 和 Bodleian 图书馆建立了合作伙伴关系，以保护全球的开源代码。我们将通过跨各种数据格式和位置存储多个副本来保护这种知识，包括一个旨在保存至少一千年的非常长期的档案库，称为 GitHub Arctic Code Vault。</p></blockquote><p><a href="https://archiveprogram.github.com/" target="_blank" rel="noopener">点击了解详情</a></p><hr><p><em>本文属于原创，首发于微信公众号「面向人生编程」，如需转载请后台留言。</em></p>]]></content>
      
      
      
        <tags>
            
            <tag> 开源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js 使用 express-jwt 解析 JWT</title>
      <link href="/2019/11/07/Node.js%20%E4%BD%BF%E7%94%A8%20express-jwt%20%E8%A7%A3%E6%9E%90%20JWT/"/>
      <url>/2019/11/07/Node.js%20%E4%BD%BF%E7%94%A8%20express-jwt%20%E8%A7%A3%E6%9E%90%20JWT/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Node.js 上 Token 鉴权常用的是 passport，它可以自定义校验策略，但如果你是用 express 框架，又只是解析 JWT 这种简单需求，可以尝试下 express-jwt 这个中间件。</p></blockquote><h2 id="关于-JWT"><a href="#关于-JWT" class="headerlink" title="关于 JWT"></a>关于 JWT</h2><p>JWT 全称 JSON Web Token，是代替传统 session 认证的解决方案。其原理是服务端生成一个包含用户唯一标识的 JSON 对象，颁发给客户端。客户端请求需要权限的接口时，只要把这个 JSON 再原样发回给服务端，服务器通过解析就可识别用户。</p><p>它通常是这个样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c</span><br></pre></td></tr></table></figure><p>这个 JSON 对象通过 <code>.</code> 分成三段，包含了请求头（加密算法）、负载信息（如 userId、过期时间），还有通过服务端密钥生成的签名来保证不被篡改。</p><p>这种机制使服务端不再需要存储 Token，因此是非常轻量的用户认证方案。并且对于微服务这种需要不同服务间共用 Token 的跨域认证，JWT 是目前的首选。</p><h2 id="关于-express-jwt"><a href="#关于-express-jwt" class="headerlink" title="关于 express-jwt"></a>关于 express-jwt</h2><p>express-jwt 是 Node.js 的一个开源库，由 ID 认证服务提供商 auth0 开发，是专用于 express 框架下解析 JWT 的中间件。</p><p>它使用非常简单，而且会自动把 JWT 的 payload 部分赋值于 <code>req.user</code>，方便逻辑部分调用。</p><h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install express-jwt</span><br></pre></td></tr></table></figure><h3 id="加入中间件"><a href="#加入中间件" class="headerlink" title="加入中间件"></a>加入中间件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> expressJwt = <span class="built_in">require</span>(<span class="string">'express-jwt'</span>)</span><br><span class="line"></span><br><span class="line">app.use(expressJwt(&#123;</span><br><span class="line">  secret: <span class="string">'secret12345'</span>  <span class="comment">// 签名的密钥 或 PublicKey</span></span><br><span class="line">&#125;).unless(&#123;</span><br><span class="line">  path: [<span class="string">'/login'</span>, <span class="string">'/signup'</span>]  <span class="comment">// 指定路径不经过 Token 解析</span></span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><h3 id="生成-Token"><a href="#生成-Token" class="headerlink" title="生成 Token"></a>生成 Token</h3><p>生成 Token 的方式依然使用 <code>jsonwebtoken</code>，比如将下列代码加入到登录接口的返回部分：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> jwt = <span class="built_in">require</span>(<span class="string">'jsonwebtoken'</span>)</span><br><span class="line"></span><br><span class="line">app.post(<span class="string">'/login'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 注意默认情况 Token 必须以 Bearer+空格 开头</span></span><br><span class="line">  <span class="keyword">const</span> token = <span class="string">'Bearer '</span> + jwt.sign(</span><br><span class="line">    &#123;</span><br><span class="line">      _id: user._id,</span><br><span class="line">      admin: user.role === <span class="string">'admin'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'secret12345'</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      expiresIn: <span class="number">3600</span> * <span class="number">24</span> * <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">  res.json(&#123;</span><br><span class="line">    status: <span class="string">'ok'</span>,</span><br><span class="line">    data: &#123; <span class="attr">token</span>: token &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="获取解析内容"><a href="#获取解析内容" class="headerlink" title="获取解析内容"></a>获取解析内容</h3><p>当收到带 Token 的请求，如果解析成功，就可以在路由回调里通过 <code>req.user</code> 来访问：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/protected'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!req.user.admin)</span><br><span class="line">    <span class="keyword">return</span> res.sendStatus(<span class="number">401</span>)</span><br><span class="line">  res.sendStatus(<span class="number">200</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>req.user</code> 实际就是 JWT 的 payload 部分：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  _id: <span class="string">'5dbbc7daaf7dfe003680ba39'</span>,</span><br><span class="line">  admin: <span class="literal">true</span>,</span><br><span class="line">  iat: <span class="number">1572587484</span>,</span><br><span class="line">  exp: <span class="number">1573192284</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解析失败"><a href="#解析失败" class="headerlink" title="解析失败"></a>解析失败</h3><p>如果解析失败，会抛出 <code>UnauthorizedError</code>，可以通过后置中间件来捕获：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="function"><span class="keyword">function</span> (<span class="params">err, req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err.name === <span class="string">'UnauthorizedError'</span>) &#123;   </span><br><span class="line">    res.status(<span class="number">401</span>).send(<span class="string">'invalid token'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="修改结果字段"><a href="#修改结果字段" class="headerlink" title="修改结果字段"></a>修改结果字段</h3><p>默认解析结果会赋值在 <code>req.user</code>，也可以通过 <code>requestProperty</code> 来修改：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.use(expressJwt(&#123;</span><br><span class="line">  secret: <span class="string">'secret12345'</span>,</span><br><span class="line">  requestProperty: <span class="string">'auth'</span></span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><h3 id="允许无-Token-请求"><a href="#允许无-Token-请求" class="headerlink" title="允许无 Token 请求"></a>允许无 Token 请求</h3><p>当接口允许不带 Token 和带 Token 两种状态的访问时（比如文章详情登录后判断点赞），可以通过 <code>credentialsRequired: false</code> 来对无 Token 请求不进行解析和抛出异常。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.use(expressJwt(&#123;</span><br><span class="line">  secret: <span class="string">'secret12345'</span>,</span><br><span class="line">  credentialsRequired: <span class="literal">false</span></span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><h3 id="自定义解析"><a href="#自定义解析" class="headerlink" title="自定义解析"></a>自定义解析</h3><p>默认情况下，express-jwt 是从请求 Headers 的 <code>Authorization</code> 字段来获取 Token 并解析。</p><p>通过 <code>getToken</code> 也可以自定义一些解析逻辑，比如使用其他 Header 字段，自定义抛出异常等：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">app.use(expressJwt(&#123;</span><br><span class="line">  secret: <span class="string">'secret12345'</span>,</span><br><span class="line">  credentialsRequired: <span class="literal">false</span>,</span><br><span class="line">  getToken: <span class="function"><span class="keyword">function</span> <span class="title">fromHeaderOrQuerystring</span> (<span class="params">req</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (req.headers.authorization &amp;&amp; req.headers.authorization.split(<span class="string">' '</span>)[<span class="number">0</span>] === <span class="string">'Bearer'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> req.headers.authorization.split(<span class="string">' '</span>)[<span class="number">1</span>]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (req.query &amp;&amp; req.query.token) &#123;</span><br><span class="line">      <span class="keyword">return</span> req.query.token</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><h3 id="作废-Token"><a href="#作废-Token" class="headerlink" title="作废 Token"></a>作废 Token</h3><p>在 JWT 机制中，由于 Token 通常不进行存储，如果想作废某一条 Token，一般都是通过被动的方式。</p><p>常用的方式是建立某个字段的黑名单（比如 TokenId），对所有 Token 进行过滤，express-jwt 专门提供了回调来处理这种情况：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> expressJwt = <span class="built_in">require</span>(<span class="string">'express-jwt'</span>)</span><br><span class="line"><span class="keyword">const</span> blacklist = <span class="built_in">require</span>(<span class="string">'./blacklist'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> isRevokedCallback = <span class="function"><span class="keyword">function</span>(<span class="params">req, payload, done</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> issuer = payload.iss</span><br><span class="line">  <span class="keyword">let</span> tokenId = payload.jti</span><br><span class="line"></span><br><span class="line">  blacklist.getRevokedToken(issuer, tokenId, <span class="function"><span class="keyword">function</span>(<span class="params">err, token</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123; <span class="keyword">return</span> done(err) &#125;</span><br><span class="line">    <span class="keyword">return</span> done(<span class="literal">null</span>, !!token)  <span class="comment">// 第二个参数为 true 则不通过</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.use(expressJwt(&#123;</span><br><span class="line">  secret: <span class="string">'secret12345'</span>,</span><br><span class="line">  isRevoked: isRevokedCallback</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><p>更多用法可以查看 <a href="https://github.com/auth0/express-jwt" target="_blank" rel="noopener">官方文档</a>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 3.8.0 正式版发布，新特性初体验</title>
      <link href="/2019/10/16/Python%203.8.0%20%E6%AD%A3%E5%BC%8F%E7%89%88%E5%8F%91%E5%B8%83%EF%BC%8C%E6%96%B0%E7%89%B9%E6%80%A7%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
      <url>/2019/10/16/Python%203.8.0%20%E6%AD%A3%E5%BC%8F%E7%89%88%E5%8F%91%E5%B8%83%EF%BC%8C%E6%96%B0%E7%89%B9%E6%80%A7%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<blockquote><p>北京时间 10 月 15 日，Python 官方发布了 3.8.0 正式版，该版本较 3.7 版本再次带来了多个非常实用的新特性。</p></blockquote><h2 id="赋值表达式"><a href="#赋值表达式" class="headerlink" title="赋值表达式"></a>赋值表达式</h2><p>PEP 572: Assignment Expressions</p><p>新增一种新语法形式：<code>:=</code>，又称为“海象运算符”（为什么叫海象，看看这两个符号像不像颜表情），如果你用过 Go 语言，应该对这个语法非常熟悉。</p><p>具体作用我们直接用实例来展示，比如在使用正则匹配时，以往版本中我们会如下写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">pattern = re.compile(<span class="string">'a'</span>)</span><br><span class="line">data = <span class="string">'abc'</span></span><br><span class="line">match = pattern.search(data)</span><br><span class="line"><span class="keyword">if</span> match <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">    print(match.group(<span class="number">0</span>))</span><br></pre></td></tr></table></figure><p>而使用赋值表达式时，我们可以改写为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (match := pattern.search(data)) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">    print(match.group(<span class="number">0</span>))</span><br></pre></td></tr></table></figure><p>在 if 语句中同时完成了求值、赋值变量、变量判断三步操作，再次简化了代码。</p><p>下面是在列表表达式中的用法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filtered_data = [y <span class="keyword">for</span> x <span class="keyword">in</span> data <span class="keyword">if</span> (y := func(x)) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>]</span><br></pre></td></tr></table></figure><h2 id="强制位置参数"><a href="#强制位置参数" class="headerlink" title="强制位置参数"></a>强制位置参数</h2><p>PEP 570: Python Positional-Only parameters</p><p>新增一个函数形参标记：<code>/</code>，用来表示标记左侧的参数，都只接受位置参数，不能使用关键字参数形式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">pow</span><span class="params">(x, y, z=None, /)</span>:</span></span><br><span class="line"><span class="meta">... </span>    r = x ** y</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> r <span class="keyword">if</span> z <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> r%z</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pow(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line"><span class="number">125</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pow(x=<span class="number">5</span>, y=<span class="number">3</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: pow() takes no keyword arguments</span><br></pre></td></tr></table></figure><p>这实际上是用纯 Python 代码来模拟现有 C 代码实现的内置函数中类似功能，比如内置函数 <code>len(&#39;string&#39;)</code> 传参是不能使用关键字参数的。</p><h2 id="Runtime-审计钩子"><a href="#Runtime-审计钩子" class="headerlink" title="Runtime 审计钩子"></a>Runtime 审计钩子</h2><p>PEP 578: Python Runtime Audit Hooks</p><p>这让我们可以对某些事件和 API 添加一些钩子，用于在运行时监听事件相关的参数。</p><p>比如这里监听 urllib 请求：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">audit_hook</span><span class="params">(event, args)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> event <span class="keyword">in</span> [<span class="string">'urllib.Request'</span>]:</span><br><span class="line"><span class="meta">... </span>        print(<span class="string">f'<span class="subst">&#123;event=&#125;</span> <span class="subst">&#123;args=&#125;</span>'</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.addaudithook(audit_hook)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>urllib.request.urlopen(<span class="string">'https://httpbin.org/get?a=1'</span>)</span><br><span class="line">event = <span class="string">'urllib.Request'</span> args =( <span class="string">'https://httpbin.org/get?a=1'</span> , <span class="literal">None</span> , &#123;&#125;, <span class="string">'GET'</span> )</span><br><span class="line">&lt;http.client.HTTPResponse object at <span class="number">0x108f09b38</span>&gt;</span><br></pre></td></tr></table></figure><p>官方内置了一些 API，具体可查看 <a href="https://www.python.org/dev/peps/pep-0578/#suggested-audit-hook-locations" target="_blank" rel="noopener">PEP-578 规范文档</a>，也可以自定义。</p><h2 id="f-strings-支持等号"><a href="#f-strings-支持等号" class="headerlink" title="f-strings 支持等号"></a>f-strings 支持等号</h2><p>在 Python 3.6 版本中增加了 f-strings，可以使用 f 前缀更方便地格式化字符串，同时还能进行计算，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">f'<span class="subst">&#123;x+<span class="number">1</span>&#125;</span>'</span>)</span><br><span class="line"><span class="number">11</span></span><br></pre></td></tr></table></figure><p>在 3.8 中只需要增加一个 <code>=</code> 符号，即可拼接运算表达式与结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">f'<span class="subst">&#123;x+<span class="number">1</span>=&#125;</span>'</span>)</span><br><span class="line"><span class="string">'x+1=11'</span></span><br></pre></td></tr></table></figure><p>这个特性官方指明了适用于 Debug。</p><h2 id="Asyncio-异步交互模式"><a href="#Asyncio-异步交互模式" class="headerlink" title="Asyncio 异步交互模式"></a>Asyncio 异步交互模式</h2><p>在之前版本的 Python 交互模式中（REPL），涉及到 Asyncio 异步函数，通常需要使用 <code>asyncio.run(func())</code> 才能执行。</p><p>而在 3.8 版本中，当使用 <code>python -m asyncio</code> 进入交互模式，则不再需要 <code>asyncio.run</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> <span class="string">'test'</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">await</span> test()</span><br><span class="line"><span class="string">'test'</span></span><br></pre></td></tr></table></figure><h2 id="跨进程共享内存"><a href="#跨进程共享内存" class="headerlink" title="跨进程共享内存"></a>跨进程共享内存</h2><p>在 Python 多进程中，不同进程之间的通信是常见的问题，通常的方式是使用 <code>multiprocessing.Queue</code> 或者 <code>multiprocessing.Pipe</code>，在 3.8 版本中加入了 <code>multiprocessing.shared_memory</code>，利用专用于共享 Python 基础对象的内存区域，为进程通信提供一个新的选择。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> shared_memory</span><br><span class="line"></span><br><span class="line">share_nums = shared_memory.ShareableList(range(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work1</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        nums[i] += <span class="number">10</span></span><br><span class="line">    print(<span class="string">'work1 nums = %s'</span>% nums)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work2</span><span class="params">(nums)</span>:</span></span><br><span class="line">    print(<span class="string">'work2 nums = %s'</span>% nums)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p1 = Process(target=work1, args=(share_nums, ))</span><br><span class="line">    p1.start()</span><br><span class="line">    p1.join()</span><br><span class="line">    p2 = Process(target=work2, args=(share_nums, ))</span><br><span class="line">    p2.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果：</span></span><br><span class="line"><span class="comment"># work1 nums = [10, 11, 12, 13, 14]</span></span><br><span class="line"><span class="comment"># work2 nums = [10, 11, 12, 13, 14]</span></span><br></pre></td></tr></table></figure><p>以上代码中 work1 与 work2 虽然运行在两个进程中，但都可以访问和修改同一个 <code>ShareableList</code> 对象。</p><h2 id="cached-property"><a href="#cached-property" class="headerlink" title="@cached_property"></a>@cached_property</h2><p>熟悉 Python Web 开发的同学，对 <code>werkzeug.utils.cached_property</code> 与 <code>django.utils.functional.cached_property</code> 这两个装饰器一定非常熟悉，它们是内置 <code>@property</code> 装饰器的加强版，被装饰的实例方法不仅变成了属性调用，还会自动缓存方法的返回值。</p><p>现在官方终于加入了自己的实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> time</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> cached_property</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Example</span>:</span></span><br><span class="line"><span class="meta">... </span>    @cached_property</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">result</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        time.sleep(<span class="number">1</span>) <span class="comment"># 模拟计算耗时</span></span><br><span class="line"><span class="meta">... </span>        print(<span class="string">'work 1 sec...'</span>)</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="number">10</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e = Example()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e.result</span><br><span class="line">work <span class="number">1</span> sec...</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e.result <span class="comment"># 第二次调用直接使用缓存，不会耗时</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><h2 id="其他改进"><a href="#其他改进" class="headerlink" title="其他改进"></a>其他改进</h2><ul><li>PEP 587: Python 初始化配置</li><li>PEP 590: Vectorcall，用于 CPython 的快速调用协议</li><li><code>finally:</code> 中现在允许使用 <code>continue</code></li><li><code>typed_ast</code> 被合并回 CPython</li><li><code>pickle</code> 现在默认使用协议4，提高了性能</li><li><code>LOAD_GLOBAL</code> 速度加快了 40％</li><li><code>unittest</code> 加入了异步支持</li><li>在 Windows 上，默认 asyncio 事件循环现在是 <code>ProactorEventLoop</code></li><li>在 macOS 上，<code>multiprocessing</code> 启动方法默认使用 <code>spawn</code></li></ul><p>更多具体变化，可查看 <a href="https://docs.python.org/3.8/whatsnew/3.8.html" target="_blank" rel="noopener">What’s New In Python 3.8</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决 Mac OS 10.14 环境下 gem install ERROR</title>
      <link href="/2019/10/02/%E8%A7%A3%E5%86%B3%20Mac%20OS%2010.14%20%E7%8E%AF%E5%A2%83%E4%B8%8B%20gem%20install%20ERROR/"/>
      <url>/2019/10/02/%E8%A7%A3%E5%86%B3%20Mac%20OS%2010.14%20%E7%8E%AF%E5%A2%83%E4%B8%8B%20gem%20install%20ERROR/</url>
      
        <content type="html"><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul><li>Mac OS Mojave 10.14</li><li>ruby 2.3.7p456 (2018-03-28 revision 63024)</li></ul><h2 id="报错信息"><a href="#报错信息" class="headerlink" title="报错信息"></a>报错信息</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo gem install sass</span></span><br><span class="line">Building native extensions. This could take a while...</span><br><span class="line">ERROR:  Error installing sass:</span><br><span class="line">ERROR: Failed to build gem native extension.</span><br><span class="line"></span><br><span class="line">    current directory: /Library/Ruby/Gems/2.3.0/gems/ffi-1.11.1/ext/ffi_c</span><br><span class="line">/System/Library/Frameworks/Ruby.framework/Versions/2.3/usr/bin/ruby -I /Library/Ruby/Site/2.3.0 -r ./siteconf20191022-2775-1q9uxye.rb extconf.rb</span><br><span class="line">mkmf.rb can't find header files for ruby at /System/Library/Frameworks/Ruby.framework/Versions/2.3/usr/lib/ruby/include/ruby.h</span><br><span class="line"></span><br><span class="line">extconf failed, exit code 1</span><br><span class="line"></span><br><span class="line">Gem files will remain installed in /Library/Ruby/Gems/2.3.0/gems/ffi-1.11.1 for inspection.</span><br><span class="line">Results logged to /Library/Ruby/Gems/2.3.0/extensions/universal-darwin-18/2.3.0/ffi-1.11.1/gem_make.out</span><br></pre></td></tr></table></figure><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>如果是之前的 Mac OS 版本，网上都是通过 <code>xcode-select --install</code> 来解决，但是我在 Mac OS 10.14 版本下，依然存在报错。</p><p>最终找到解决方式，执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open /Library/Developer/CommandLineTools/Packages/macOS_SDK_headers_for_macOS_10.14.pkg</span><br></pre></td></tr></table></figure><p>然后根据提示安装即可。</p><p>参考链接：<a href="https://github.com/castwide/vscode-solargraph/issues/78" target="_blank" rel="noopener">https://github.com/castwide/vscode-solargraph/issues/78</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 爬坑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>众咖云集的 PyCon 2019 上海站，大佬们都讲了啥</title>
      <link href="/2019/09/22/%E4%BC%97%E5%92%96%E4%BA%91%E9%9B%86%E7%9A%84%20PyCon%202019%20%E4%B8%8A%E6%B5%B7%E7%AB%99%EF%BC%8C%E5%A4%A7%E4%BD%AC%E4%BB%AC%E9%83%BD%E8%AE%B2%E4%BA%86%E5%95%A5/"/>
      <url>/2019/09/22/%E4%BC%97%E5%92%96%E4%BA%91%E9%9B%86%E7%9A%84%20PyCon%202019%20%E4%B8%8A%E6%B5%B7%E7%AB%99%EF%BC%8C%E5%A4%A7%E4%BD%AC%E4%BB%AC%E9%83%BD%E8%AE%B2%E4%BA%86%E5%95%A5/</url>
      
        <content type="html"><![CDATA[<p>9 月 21 号周六，我参加了 PyCon China 2019 上海站，这是每年一届的 Python 中国开发者大会。</p><p><img src="http://static.zkqiang.cn/images/20190922124621.jpg-slim" alt=""></p><p>今年的上海站比往年的阵容扩大很多，「流畅的 Python」作者、Flask 作者及核心维护者、PyCharm 开发者等等大佬都登台演讲。</p><p>本文将总结一下我观看的演讲，但并不会深入和完整，如有感兴趣的主题，可以等待官方后续放出的视频，我的公众号到时候也会转载。</p><h2 id="Python-的永恒之美"><a href="#Python-的永恒之美" class="headerlink" title="Python 的永恒之美"></a>Python 的永恒之美</h2><p><img src="http://static.zkqiang.cn/images/20190922124620.jpg-slim" alt=""></p><p>「流畅的 Python」作者 Luciano Ramalho，作为首场演讲的嘉宾，他的讲题围绕着 Python 之禅（PEP 20: The Zen of Python），结合了国际象棋、围棋、甚至易经，再次诠释 Python 语法的优美之处。</p><p>他还表示 Python 非常适合女性开发，介绍了 Python 开发团队拥有很多女性加入，顺带调侃了 Python 作者 Guido 在演讲中只回答女性的提问。</p><h2 id="通过-Azure-实现图片分类"><a href="#通过-Azure-实现图片分类" class="headerlink" title="通过 Azure 实现图片分类"></a>通过 Azure 实现图片分类</h2><p><img src="http://static.zkqiang.cn/images/20190922131825.jpg-slim" alt=""></p><p>第二场是由微软开发者 Dave Glover，介绍如何使用 Python 与微软 Azure 的免费云服务，构建一套 IoT 图片分类系统，并演示了开发一个水果分类功能，将不同水果的图片进行简单训练后，就可以用于超市收银台快速计算不同水果的价格（不过现场似乎因为音画不同步，导致有些小意外…）。</p><p>另外下午场微软 VS Code 还现场发布了在 Python 领域的新功能，具体可见公众号次条推送。</p><h2 id="AWS-Serverless-一站式开发"><a href="#AWS-Serverless-一站式开发" class="headerlink" title="AWS Serverless 一站式开发"></a>AWS Serverless 一站式开发</h2><p><img src="http://static.zkqiang.cn/images/20190922141104.jpg-slim" alt=""></p><p>结束了前两场英语听力后（翻译在文末吐槽），第三场是来自宝岛台湾的谢洪恩，他是 AWS 无服务器与容器专家解决方案架构师。他介绍了 AWS 近几年在 Serverless 领域发布的新技术，主要包括：</p><ul><li>AWS Lambda</li><li>AWS SAR（Serverless Application Repository）</li><li>AWS CDK（Cloud Development Kit）</li></ul><p>利用这些技术让 Python 开发者在无服务器的情况下，完成一站式开发部署（也支持其它多种语言），并且还介绍了在微服务框架中的应用。</p><p>另外在下午场中，谢老师还进行了三个小时的 AWS WorkShop 专场，现场指导开发者们，在 AWS CDK 中从零开始完成一个完整项目。但可惜由于时间冲突，我没有选择参加。</p><h2 id="Flask-作者谈调试"><a href="#Flask-作者谈调试" class="headerlink" title="Flask 作者谈调试"></a>Flask 作者谈调试</h2><p><img src="http://static.zkqiang.cn/images/20190922141939.jpg-slim" alt=""></p><p>Flask、Werkzeug、Jinja2、Click 等开源项目的作者 Armin Ronacher，讲述他在 Python 调试方面的新看法，并通过最近使用 Rust 语言的开发经历，发现了 Python 在性能上较慢反而对调试有帮助。</p><p>遗憾的是他英语语速很快，PPT 文字内容也比较少，我并没有听懂太多细节，需要等待视频再复习一波。</p><h2 id="在调试上的新实现"><a href="#在调试上的新实现" class="headerlink" title="在调试上的新实现"></a>在调试上的新实现</h2><p><img src="http://static.zkqiang.cn/images/20190922142519.jpg-slim" alt=""></p><p>上午最后一场，是由 Google 软件工程师、《捕蛇者说》播客创始人 laike9m 演讲，同样是调试的话题，但他带来的是一个新思路，以及已经实现的开源库 —— <a href="https://github.com/laike9m/Cyberbrain" target="_blank" rel="noopener">Cyberbrain</a>。</p><p>主要思路是对目标变量进行追踪，通过可视化界面查看变量从初始化一直到目标行的过程，从而帮助快速定位 BUG。</p><p>以下是一段示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func_f</span><span class="params">(bar)</span>:</span></span><br><span class="line">    x = len(bar)</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func_c</span><span class="params">(baa)</span>:</span></span><br><span class="line">    baa.append(<span class="literal">None</span>)</span><br><span class="line">    baa.append(<span class="string">'?'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func_a</span><span class="params">(foo)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>): <span class="keyword">pass</span></span><br><span class="line">    ba = [foo]</span><br><span class="line">    func_c(ba)</span><br><span class="line">    foo = func_f(ba)</span><br><span class="line">    cyberbrain.register(foo)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cyberbrain</span><br><span class="line">cyberbrain.init()</span><br><span class="line">fo = <span class="number">1</span></span><br><span class="line">func_a(fo)</span><br></pre></td></tr></table></figure><p>通过对 <code>foo</code> 变量的注册，可以产生以下输出：</p><p><img src="http://static.zkqiang.cn/images/20190922162303.jpeg-slim" alt=""></p><p>并且支持持久化存储，即使在服务器上也可以 DEBUG。</p><h2 id="AIOps-数据中台与-Python"><a href="#AIOps-数据中台与-Python" class="headerlink" title="AIOps 数据中台与 Python"></a>AIOps 数据中台与 Python</h2><p><img src="http://static.zkqiang.cn/images/20190922163054.jpg-slim" alt=""></p><p>下午场都是同时开始的分会场，所以我只能选择听自己感兴趣的场次。</p><p>最近两年“中台”概念比较火，我公司也已经有中台，所以我首场选择了这个中台话题的场次，嘉宾是来自阿里云日志服务的丁来强。</p><p>他演讲的内容主要是介绍目前市面上众多 AIOps 平台，并介绍如何通过开源的 AIOps 搭建数据中台，来解决数据收集、算法处理海量日志等以往需要大量人工的问题。</p><p>至于 Ops 的未来趋势，他表示：</p><blockquote><p>根据 Gartner 的报告，AIOps 将在未来 5-10 年落地开花，并集中统一各种 Ops 平台（Dev、IT、Net、Sec）。</p></blockquote><h2 id="Django-中运用-GraphQL"><a href="#Django-中运用-GraphQL" class="headerlink" title="Django 中运用 GraphQL"></a>Django 中运用 GraphQL</h2><p>先介绍一下 GraphQL，它是 Facebook 发布 API 查询语言，旨在提供 RestFul 架构体系的替代方案，但一直鲜有人用，甚至鲜有人知。</p><p>目前 RestFul API 存在的问题是，返回的数据结构和类型都是后端定义，前端需求变化，后端也要随之改变，如果是中大型项目，改动接口是会产生大量连带工作量。</p><p>而 GraphQL 就是解决这一痛点，它实现了前端可以自定义请求字段与结构，而后端则专心处理请求逻辑与数据库映射。具体不再多介绍，可查阅相关资料。</p><p><img src="http://static.zkqiang.cn/images/20190922172502.jpg-slim" alt=""></p><p>LeetCode 后端架构师李齐雨，介绍了 LeetCode 在最近两年，已经将十几万行 Django 代码构成的所有接口，更换为了 GraphQL。</p><p>更换后的好处则如上面所介绍，让接口迭代更加灵活。他主要分享的是期间遇到的一些问题，以及如何攻克，比如数据转换、查询性能优化等。</p><p>不过他也直言，如果对接口性能要求很高，建议暂时不要使用 GraphQL。</p><h2 id="构建自动化测试集群"><a href="#构建自动化测试集群" class="headerlink" title="构建自动化测试集群"></a>构建自动化测试集群</h2><p><img src="http://static.zkqiang.cn/images/20190922180928.jpg-slim" alt=""></p><p>这一场是网易 Airtest 团队负责人杨柳，前半部分是介绍 Airtest 这一开源的自动化测试框架，在跨平台特别是 App、手游这方面的优势，框架集成的图像识别、控件识别大幅增加了自动化能力。</p><p>后半部分是分享网易游戏如何将自动化测试逐步扩展为大规模测试集群，并且介绍了如何使用 3x4 小型机柜，实现一个企业级、私有化的测试解决方案。</p><h2 id="通过-Python-构建-RPC"><a href="#通过-Python-构建-RPC" class="headerlink" title="通过 Python 构建 RPC"></a>通过 Python 构建 RPC</h2><p><img src="http://static.zkqiang.cn/images/20190922183157.jpg-slim" alt=""></p><p>来自饿了么的资深工程师张汝家，先是介绍了 thrift 这一款 RPC 协议，在目前微服务架构中的应用，以及目前 Python 实现的 thriftpy 和 thriftpy2 的区别和各自的应用场景。</p><p>然后他分享了使用 thriftpy 构建一套 RPC 协议架构的过程，中间不同分层该如何设计，并且其中一些通信与传输问题是如何解决的。</p><h2 id="闪电演讲"><a href="#闪电演讲" class="headerlink" title="闪电演讲"></a>闪电演讲</h2><p>最后的场次，是本届 PyCon 设置的新环节，每位嘉宾只有 5 分钟时间演讲，可惜部分嘉宾超时未完成演讲，实际效果欠佳。</p><p>不过有一个印象深刻的主题是将 C/C++ 代码转换为 .pyd 文件，Python 可直接调用。</p><p><img src="http://static.zkqiang.cn/images/20190922184628.jpg-slim" alt=""></p><p>演讲者是上海韦纳科技的韦泽华，他实现了此功能并开源名为 <a href="https://github.com/nanoric/c2py" target="_blank" rel="noopener">c2py</a>，该项目与之前类似功能的 Swig 相比，c2py 更加易用，不需要像 Swig 写接口文件，just run c2py &amp; build。</p><h2 id="本次大会的观后感"><a href="#本次大会的观后感" class="headerlink" title="本次大会的观后感"></a>本次大会的观后感</h2><p>相较于往期有非常大的进步，主要是：</p><ul><li>本届大咖云集，通过多位著名项目核心开发者的分享，学习他们在各自领域中独到的见解；</li><li>分会场的设立，充分扩大了演讲的主题范围，也满足了不同方向的开发者不同的关注点。</li></ul><p>但依然有部分遗憾之处，比如：</p><ul><li>第一场半程，某赞助商的 AI 翻译就莫名罢工，并且一上午都没有再启动，导致我等英语苦手，对三位国外大佬的演讲吸收量大减；</li><li>WorkShop 设置在下午分会场，如果选择了就相当于无缘同时间段的三场演讲，纠结之下我只能放弃参与。</li></ul><p>总体本届还是收获满满，票价超值了，也看出主办方想办好 PyCon China 的决心，希望明年再加油，PyCon 明年见！</p><hr><p><em>所有图片来自 PyCon China 官方拍摄</em></p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown 直接转换公众号文章，不再为排版花时间</title>
      <link href="/2019/09/16/Markdown%20%E7%9B%B4%E6%8E%A5%E8%BD%AC%E6%8D%A2%E5%85%AC%E4%BC%97%E5%8F%B7%E6%96%87%E7%AB%A0%EF%BC%8C%E4%B8%8D%E5%86%8D%E4%B8%BA%E6%8E%92%E7%89%88%E8%8A%B1%E6%97%B6%E9%97%B4/"/>
      <url>/2019/09/16/Markdown%20%E7%9B%B4%E6%8E%A5%E8%BD%AC%E6%8D%A2%E5%85%AC%E4%BC%97%E5%8F%B7%E6%96%87%E7%AB%A0%EF%BC%8C%E4%B8%8D%E5%86%8D%E4%B8%BA%E6%8E%92%E7%89%88%E8%8A%B1%E6%97%B6%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<p>上一篇<a href="https://mp.weixin.qq.com/s/fSjEizj-tqoMV7ior8XiLg" target="_blank" rel="noopener">「又一家数据公司被查，爬虫到底做错了什么？」</a>反响强烈，虽然我这是新号，但还是获得了不少公众号的转发，借机也结识了很多业内大佬，在此感谢大家的抬爱！</p><p>同时也有不少号主问我的文章排版是用的哪个网站，我的回答是：自己做的网站！</p><p>没错，这就是本文的主角<br>—— <strong><a href="http://prod.zkqiang.cn/wxeditor" target="_blank" rel="noopener">公众号 Markdown 编辑器</a></strong></p><p><img src="http://static.zkqiang.cn/images/20190913221225.png-slim" alt=""></p><p>这是我基于一位大佬 @Lyric 开发的项目，进行 Fork 后的二次开发，因为原项目已经几个月没更新，有一些排版 BUG；而且我需要对样式进行个性化定制，有一些逻辑与原项目有冲突之处，所以没有选择 PR。</p><p>上面截图，也就是我目前发文的格式，这是我自己定制的主题样式。</p><h2 id="有多好用？"><a href="#有多好用？" class="headerlink" title="有多好用？"></a>有多好用？</h2><p>先介绍下使用方式：在其他 Markdown 编辑器里写文章，全文粘贴到左栏，然后复制右栏，再粘贴到公众号后台，完了！</p><p>不需要再有多余的步骤，你复制过去的样式就是右栏看到的。</p><p><img src="http://static.zkqiang.cn/images/20190913213757.png-slim" alt=""></p><p>当然你也可以进行微调，比如添加字体的衬线、改字号，也有原作者提供的两种主题样式可选。</p><p>就是这款编辑器彻底<strong>解放</strong>了我。</p><p>毕竟我是公众号新人，对排版这种事情处于小白级别。我也知道传统情况下，文章写好只是发文的前半部分，还需要花大量时间去排版，给读者舒服的感觉，而该项目直接省掉了后半部分的时间，可以更专注于写作。</p><blockquote><p>另外，虽然是面向公众号，但经过测试，在其他不支持 Markdown 的平台上也同样可以使用。</p></blockquote><h2 id="更多细节"><a href="#更多细节" class="headerlink" title="更多细节"></a>更多细节</h2><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>通过定制支持了代码高亮的配色，我这里使用了大家熟悉的 Github 配色。</p><p><img src="http://static.zkqiang.cn/images/20190913214602.png-slim" alt=""></p><h3 id="注音符号"><a href="#注音符号" class="headerlink" title="注音符号"></a>注音符号</h3><p>这个是通过第三方库实现的，可以搞一些比如「丧心病狂{gàn・de・piào・liàng}」很有意思的效果。</p><p><img src="http://static.zkqiang.cn/images/20190913214803.png-slim" alt=""></p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>这也是个很有意思的功能点，公众号文章里放微信之外的链接，是无法点击跳转的，所以原作者把这种链接全部放在了文章末尾，就像学术文章的出处引用一样。</p><p><img src="http://static.zkqiang.cn/images/20190913215245.png-slim" alt=""></p><p>其他的细节可以看编辑器的默认文章。</p><h2 id="定制自己的样式"><a href="#定制自己的样式" class="headerlink" title="定制自己的样式"></a>定制自己的样式</h2><p>如果你不想和我雷同，或者觉得我的样式不好看，那也可以自己再定制，只需要一点前端 CSS 基础即可。</p><p>这里不建议你 Fork 后开发自用，我希望大家可以把更多样式 PR 给我，放入项目中开源出去。</p><p>另外我还会对编辑器里面的逻辑进行优化，还有一些基础功能也暂时缺失，比如没有保存、没有修改高亮样式、没有在页面就能改各种样式的功能，这些都在我计划之内，如果你有更好的想法也欢迎发给我。</p><p><a href="http://prod.zkqiang.cn/wxeditor" target="_blank" rel="noopener">&gt;&gt;&gt;&gt;&gt; 公众号编辑器地址 &lt;&lt;&lt;&lt;&lt;</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 开源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>又一家数据公司被查，爬虫到底做错了什么？</title>
      <link href="/2019/09/07/%E5%8F%88%E4%B8%80%E5%AE%B6%E6%95%B0%E6%8D%AE%E5%85%AC%E5%8F%B8%E8%A2%AB%E6%9F%A5%EF%BC%8C%E7%88%AC%E8%99%AB%E5%88%B0%E5%BA%95%E5%81%9A%E9%94%99%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
      <url>/2019/09/07/%E5%8F%88%E4%B8%80%E5%AE%B6%E6%95%B0%E6%8D%AE%E5%85%AC%E5%8F%B8%E8%A2%AB%E6%9F%A5%EF%BC%8C%E7%88%AC%E8%99%AB%E5%88%B0%E5%BA%95%E5%81%9A%E9%94%99%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>9 月 6 日下午，多位业内人士称，杭州知名大数据服务公司杭州魔蝎数据科技有限公司，疑似被相关执法人员控制，其中一位周姓核心高管人员被警方带走。</p></blockquote><p>以上是前几天技术圈传播的一则新闻，又一家数据公司被调查，很多数据从业者、爬虫开发者发出了“感叹” —— 「爬虫用得好，XX进得早；数据玩得溜，XX吃个够」。</p><p>魔蝎科技作为一家数据服务公司，曾在 2017 年一篇『爬虫凶猛：爬支付宝、爬微信、窃取现金贷放贷数据』的文章中，被指出存在开发使用恶意爬虫的行为。</p><p>当然关于魔蝎科技为什么被查，这个等待执法部门的调查结果即可，咱们不在这里无端猜测。</p><p>我今天要说的是关于爬虫的合法性，我希望通过一些案例来探讨：怎样做一个不触碰红线的爬虫开发者。</p><p><img src="http://static.zkqiang.cn/images/20190907184257.jpg-slim" alt=""></p><p>爬虫作为一种计算机技术，具有技术中立性，爬虫技术在法律上从来没有被禁止。爬虫的发展历史可以追溯到 20 年前，搜索引擎、聚合导航、数据分析、人工智能等业务，都需要基于爬虫技术。</p><p>但是爬虫作为获取数据的技术手段之一，由于部分数据存在敏感性，如果不能甄别哪些数据是可以爬取，哪些会触及红线，可能下一位上新闻的主角就是你。</p><p>如何界定爬虫的合法性，目前没有明文规定，但我通过翻阅大量文章、事件、分享、司法案例，我总结出界定的三个关键点：<strong>采集途径</strong>、<strong>采集行为</strong>、<strong>使用目的</strong>。</p><h2 id="数据的采集途径"><a href="#数据的采集途径" class="headerlink" title="数据的采集途径"></a>数据的采集途径</h2><p>通过什么途径爬取数据，这个是最需要重视的一点。总体来说，<strong>未公开、未经许可、且带有敏感信息</strong>的数据，不管是通过什么渠道获得，都是一种不合法的行为。</p><p>所以在采集这类比较敏感的数据时，最好先查询下相关法律法规，特别是用户个人信息、其他商业平台的信息 等这类信息，寻找一条合适的途径。</p><h3 id="个人数据"><a href="#个人数据" class="headerlink" title="个人数据"></a>个人数据</h3><p>采集和分析个人信息数据，应该是当下所有互联网都会做的一件事，但是大部分个人数据都是非公开的，想获得必须通过合法途径，可参见『网络安全法』第四十一条：</p><blockquote><p>网络运营者收集、使用个人信息，应当遵循合法、正当、必要的原则，公开收集、使用规则，明示收集、使用信息的目的、方式和范围，并经被收集者同意…</p></blockquote><p>也就是必须在<strong>提前告知收集的方式、范围、目的，并经过用户授权或同意后</strong>，才能采集使用，也就是我们常见的各种网站与 App 的用户协议中关于信息收集的部分。</p><p>相关反面案例：</p><blockquote><p>8月20日，澎湃新闻从绍兴市越城区公安分局获悉，该局日前侦破一起特大流量劫持案，涉案的新三板挂牌公司北京瑞智华胜科技股份有限公司，涉嫌非法窃取用户个人信息30亿条，涉及百度、腾讯、阿里、京东等全国96家互联网公司产品，目前警方已从该公司及其关联公司抓获6名犯罪嫌疑人。<br>……<br>北京瑞智华胜公司及其关联公司在与正规运营商合作中，会加入一些非法软件用于清洗流量、获取用户的 cookie。</p></blockquote><p>节选自 <a href="https://www.thepaper.cn/newsDetail_forward_2362227" target="_blank" rel="noopener" title="新三板挂牌公司涉窃取30亿条个人信息">澎湃新闻：『新三板挂牌公司涉窃取30亿条个人信息，非法牟利超千万元』</a></p><h3 id="公开数据"><a href="#公开数据" class="headerlink" title="公开数据"></a>公开数据</h3><p>从合法公开渠道，并且不明显违背个人信息主体意愿，都没有什么问题。但如果通过<strong>破解</strong>、<strong>侵入</strong>等“黑客”手段来获取数据，那有相关法律等着你。</p><p>『刑法』第二百八十五条第二款：</p><blockquote><p>违反国家规定，侵入前款规定以外的计算机信息系统或者采用其他技术手段，获取该计算机信息系统中存储、处理或者传输的数据，或者对该计算机信息系统实施非法控制，情节严重的，处三年以下有期徒刑或者拘役，并处或者单处罚金；情节特别严重的，处三年以上七年以下有期徒刑，并处罚金。</p></blockquote><h3 id="违反-Robots-协议"><a href="#违反-Robots-协议" class="headerlink" title="违反 Robots 协议"></a>违反 Robots 协议</h3><p>虽然 Robots 协议没有法规强制遵守，但 Robots 协议作为行业约定，在遵循之下会给你带来合法支持。</p><p>因为 Robots 协议具有指导意义，如果注明 Disallow 就说明是平台明显要保护的页面数据，想爬取之前应该仔细考虑一下。</p><h2 id="数据的采集行为"><a href="#数据的采集行为" class="headerlink" title="数据的采集行为"></a>数据的采集行为</h2><p>使用技术手段应该懂得克制，一些容易对服务器和业务造成干扰甚至破坏的行为，应当充分衡量其承受能力，毕竟不是每家都是 BAT 级。</p><h3 id="高并发压力"><a href="#高并发压力" class="headerlink" title="高并发压力"></a>高并发压力</h3><p>做技术经常专注于优化，爬虫开发也是如此，想尽各种办法增加并发数、请求效率，但高并发带来的近乎 DDOS 的请求，如果对对方服务器造成压力，影响了对方正常业务，那就应该警惕了。</p><p>如果一旦导致严重后果，后果参见『刑法』第二百八十六条：</p><blockquote><p>违反国家规定，对计算机信息系统功能进行删除、修改、增加、干扰，造成计算机信息系统不能正常运行，后果严重的，构成犯罪</p></blockquote><p>所以请爬取的时候，即使没有反爬限制，也不要肆无忌惮地开启高并发，掂量一下对方服务器的实力。</p><h3 id="影响正常业务"><a href="#影响正常业务" class="headerlink" title="影响正常业务"></a>影响正常业务</h3><p>除了高并发请求，还有一些影响业务的情况，常见的比如抢单，会影响正常用户的体验。</p><h2 id="数据的使用目的"><a href="#数据的使用目的" class="headerlink" title="数据的使用目的"></a>数据的使用目的</h2><p>数据使用目的同样是一大关键，就算你通过合法途径采集的数据，如果对数据没有正确的使用，同样会存在不合法的行为。</p><h3 id="超出约定的使用"><a href="#超出约定的使用" class="headerlink" title="超出约定的使用"></a>超出约定的使用</h3><p>一种情况是公开收集的数据，但没有遵循之前告知的使用目的，比如用户协议上说只是分析用户行为，帮助提高产品体验，结果变成了出售用户画像数据。</p><p>还有一种情况，是有知识产权、著作权的作品，可能会允许你下载或引用，但明显标注了使用范围，比如不能转载、不能用于商业行为等，更不能去盗用，这些都是有法律明文保护，所以要注意使用。</p><p>其他情况就不列举了。</p><h3 id="出售个人信息"><a href="#出售个人信息" class="headerlink" title="出售个人信息"></a>出售个人信息</h3><p>关于出售个人信息，千万不要做，是法律特别指出禁止的，参见：</p><blockquote><p>根据《最高人民法院 最高人民检察院关于办理侵犯公民个人信息刑事案件适用法律若干问题的解释》第五条规定，对“情节严重”的解释：<br>（1）非法获取、出售或者提供行踪轨迹信息、通信内容、征信信息、财产信息五十条以上的；<br>（2）非法获取、出售或者提供住宿信息、通信记录、健康生理信息、交易信息等其他可能影响人身、财产安全的公民个人信息五百条以上的；<br>（3）非法获取、出售或者提供第三项、第四项规定以外的公民个人信息五千条以上的便构成“侵犯公民个人信息罪”所要求的“情节严重”。<br>此外，未经被收集者同意，即使是将合法收集的公民个人信息向他人提供的，也属于刑法第二百五十三条之一规定的“提供公民个人信息”，可能构成犯罪。</p></blockquote><h3 id="不正当商业行为"><a href="#不正当商业行为" class="headerlink" title="不正当商业行为"></a>不正当商业行为</h3><p>如果将竞品公司的数据，作为自己公司的商业目的，这就可能存在构成不正当商业竞争，或者是违反知识产权保护。</p><p>这种情况在目前涉及爬虫的商业诉讼案中比较常见，两年前比较知名的案件，“车来了” App 抓取其竞品 “酷米客” 的公交车数据，并展示在自己的产品上：</p><blockquote><p>虽然公交车作为公共交通工具，其实时运行路线、运行时间等信息仅系客观事实，但当此类信息经过人工收集、分析、编辑、整合并配合GPS精确定位，作为公交信息查询软件的后台数据后，此类信息便具有了实用性并能够为权利人带来现实或潜在、当下或将来的经济利益，已经具备无形财产的属性。元光公司利用网络爬虫技术大量获取并且无偿使用谷米公司“酷米客”软件的实时公交信息数据的行为，实为一种“不劳而获”、“食人而肥”的行为，构成不正当竞争。</p></blockquote><p>节选自『深圳市中级人民法院（2017）粤03民初822号民事判决书』</p><h2 id="「爬虫法」即将出台"><a href="#「爬虫法」即将出台" class="headerlink" title="「爬虫法」即将出台"></a>「爬虫法」即将出台</h2><p>好消息是，相关办法已经在路上了。</p><blockquote><p>5 月 28 日零点，国家互联网信息办公室发布了《数据安全管理办法》征求意见稿。</p></blockquote><p>我也查阅了这份意见稿，里面对数据的获取、存储、传输、使用等都做了一些规定，包括关于爬虫行为的若干规定（还在征求阶段，因此后续可能会有变化）。</p><p>比如，第二章第十六条：</p><blockquote><p>网络运营者采取自动化手段访问收集网站数据，不得妨碍网站正常运行；此类行为严重影响网站运行，如自动化访问收集流量超过网站日均流量三分之一，网站要求停止自动化访问收集时，应当停止。 </p></blockquote><p>第三章第二十七条：</p><blockquote><p>网络运营者向他人提供个人信息前，应当评估可能带来的安全风险，并征得个人信息主体同意。下列情况除外：<br>（一）从合法公开渠道收集且不明显违背个人信息主体意愿；<br>（二）个人信息主体主动公开；<br>（三）经过匿名化处理；<br>（四）执法机关依法履行职责所必需；<br>（五）维护国家安全、社会公共利益、个人信息主体生命安全所必需。  </p></blockquote><p>节选自<a href="http://www.moj.gov.cn/news/content/2019-05/28/zlk_235861.html" target="_blank" rel="noopener" title="数据安全管理办法（征求意见稿）">『数据安全管理办法（征求意见稿）』</a></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>关于爬虫合法性的研究就到这，有很多案例和角度由于篇幅没有提到，也有一些观点结论可能存在错误。</p><p>但希望能给各位爬虫开发者，也包括其他开发者一些启示：技术虽中立，使用有善恶，一定要合理合规、严格谨慎地使用技术。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三步搞定 Android 逆向</title>
      <link href="/2019/09/01/%E4%B8%89%E6%AD%A5%E6%90%9E%E5%AE%9A%20Android%20%E9%80%86%E5%90%91/"/>
      <url>/2019/09/01/%E4%B8%89%E6%AD%A5%E6%90%9E%E5%AE%9A%20Android%20%E9%80%86%E5%90%91/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文源于我近期的一次公司内部分享，通过逆向某款 APP 来介绍逆向过程。由于仅作为学习用途，APP 的相关信息会被遮盖，敬请理解。</p></blockquote><h2 id="关于逆向"><a href="#关于逆向" class="headerlink" title="关于逆向"></a>关于逆向</h2><p>逆向——包括但不限于通过反编译、Hook 等手段，来解析一些功能的实现过程。</p><p>逆向在很多领域都有应用，比如如今爬虫技术已经遍地走，甚至不用写代码都可以爬取数据，导致前端开发的反爬意识也逐步提升。因此 JS、Android 等领域的逆向，已经成为爬虫开发者必备的技能之一。</p><p>本文介绍的是最典型常见的传参加密，在很多应用接口都能见到，如果我们逆向解析出加密过程，就可以模拟出相同的密文，得到后端接口的“认可”。</p><h2 id="逆向的准备"><a href="#逆向的准备" class="headerlink" title="逆向的准备"></a>逆向的准备</h2><p>这里介绍下关于 Android 的逆向准备：</p><ul><li>Android 真机或模拟器（最好是真机）</li><li>安装 Android 5.0 或 6.0 版本</li><li>Fiddler、Charles 等抓包工具</li><li>Jadx、ApkTool 等反编译工具</li><li>dumpDex、FDex2 等脱壳工具</li><li>Java、Android 开发基础知识</li><li>Xposed 框架开发基础知识</li></ul><h2 id="逆向步骤"><a href="#逆向步骤" class="headerlink" title="逆向步骤"></a>逆向步骤</h2><p>介绍一下本文逆向的步骤：</p><p><img src="http://static.zkqiang.cn/images/20190901224417.png-slim" alt=""></p><p>当然，用三步概括，看上去像“把大象塞进冰箱分为几步”。逆向作为一项与应用开发者对抗的网络安全技术，其手段花样多端，有时甚至不需要代码也可以完成逆向，所以这个概括仅对应文中的遇到情况。</p><h2 id="定位目标"><a href="#定位目标" class="headerlink" title="定位目标"></a>定位目标</h2><p>本次逆向是针对某款 APP 的订单接口，首先我们使用抓包工具捕获订单列表请求，下图为 Charles 界面：</p><p><img src="http://static.zkqiang.cn/images/20190901210151.png-slim" alt=""></p><p>可以看到参数里的 data 字段是密文，我们就使用这个 API 作为目标切入点。</p><h2 id="反编译-APK"><a href="#反编译-APK" class="headerlink" title="反编译 APK"></a>反编译 APK</h2><p>这里使用的反编译工具是 Jadx，它可以将 APK 直接反编译成 Java 代码，并且具有 GUI 界面方便操作，如下图所示：</p><p><img src="http://static.zkqiang.cn/images/20190901210150.png-slim" alt=""></p><p>通过包名和一些代码分析，确定是被 360 加固后，接下来需要尝试脱壳。</p><p>脱壳使用的是 FDex2，这是一款基于 Xposed 框架的 Hook 插件，对 360 加固比较有效。它的原理是 Hook ClassLoader，然后通过反射调用 getDex 方法获取 Dex 对象并导出，这里的 Dex 就是 APP 真正执行的部分。当然并不是所有加固都可以被 Hook 到，更多脱壳手段还需要进阶研究。</p><p>FDex2 使用方式很简单，在 Xposed 框架里激活后，选择目标 APP，然后重新打开 APP 后，被捕获的 Dex 文件会被保存下来，如下图所示：</p><p><img src="http://static.zkqiang.cn/images/20190901210149.png-slim" alt=""></p><p>Dex 是什么？简单地说，在 APK 构建过程中，Java 代码编译后产生的 class 文件，需要再转化成 Dex 文件，才能被 Android 虚拟机运行。</p><p>因此我们得到的 Dex 文件，就可以再次反编译成 Java 代码，我们还是使用 Jadx，它同样支持 Dex 格式。</p><p>由于 Dex 有体积限制，会被分包，如上图我们导出了不止一个文件，可以依次加载它们，通过搜索目标 API 的关键词，来找到目标代码块，如下图所示：</p><p><img src="http://static.zkqiang.cn/images/20190901210148.png-slim" alt=""></p><p>代码一般都会被反混淆，变量和方法名都是 a b c d 这样，然后搜索一个方法名，会发现有一万个同名的变量。还好 Jadx 内置了反混淆，开启后变量和方法被重命名为唯一编号，这样搜索时就不会有重名的情况了。</p><p>之后我们通过 Jadx 将代码导出成 Gradle 项目，借助 IDEA 的强大功能开始进行代码分析。</p><h2 id="分析代码"><a href="#分析代码" class="headerlink" title="分析代码"></a>分析代码</h2><p>由于大部分方法都是被重命名的，导致可读性严重下降，无法推测每个方法到底是什么功能，如下图这些代码：</p><p><img src="http://static.zkqiang.cn/images/20190901210147.png-slim" alt=""></p><p>第一眼你除了知道它是 Google 开发包之外，无法再获得更多信息。</p><p>所以分析代码这个步骤，完全是考验你的 Java 基本功 + 耐心，二者缺一不可。</p><p>不过不要退缩，我们只要遵循一些技巧，就可以大幅减少工作量。由于分析过程比较繁琐，这里就不结合具体代码了，只做一些理论总结：</p><ol><li><strong>从目标 API 开始入手，跟踪执行流程：</strong> 比如我们刚才已经搜索到关键词代码，那就从那一行开始，通过 IDEA 查看方法功能，可以一路向下点击。</li><li><strong>只分析涉及代码块，缩小分析范围：</strong> 请求过程通常会构建 Request 对象，那参数加密一定就在构建对象之前，我们只要找到构建 Request 对象的代码，然后查看加密参数被传入之前都经过了怎样的处理，其他代码全部无视。</li><li><strong>将部分代码块复制出来进行执行：</strong> 虽然反编译的项目代码无法被整体执行，但对于冗长难懂的方法代码，我们可以连同相关代码一起复制到一个新项目中，进行编译执行，方便我们调试。</li><li><strong>尝试搜索一些关键词：</strong> 代码并不会所有都被混淆，可以尝试全局搜索一些关键词。比如 Java 常用的加密算法，我们可以搜索 RSA、AES、MD5、Encrypt、public_*key 这些关键词和正则匹配，能搜到再好不过了。</li></ol><p>当你找到了加密方法，那么可以复制出来独立执行，然后自己构建参数传入加密，通过模拟请求，看接口是否正常返回。</p><p>需要注意，如果不能正常请求，并不一定是你找错了地方，也有可能代码本身有误，反编译的代码是有几率会出现这种情况的，导致你执行的和 APK 执行的结果不同。遇到这种情况，只能通过其他手段来修正代码，如阅读 Smali 代码、通过 Hook 等手段，这种情况比较复杂，后续会有文章单独介绍。</p><h2 id="逆向之后"><a href="#逆向之后" class="headerlink" title="逆向之后"></a>逆向之后</h2><p>完成代码分析后，恭喜你已经成功完成一次逆向，接下来就可以实现一些功能，比如模拟登录请求。建议直接使用 Java 代码，因为大部分加密用的是 Java 内置的 RSA / AES 加密算法，其他语言的第三方库实现并不充分。</p><hr><p>至此本次逆向分享结束，逆向是一个大课题，本文由于篇幅原因，也只能将常见套路的大致流程介绍一下，后续一定追加更多细节部分的文章。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫工程师常用的 Chrome 插件</title>
      <link href="/2019/06/02/%E7%88%AC%E8%99%AB%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%B8%B8%E7%94%A8%E7%9A%84%20Chrome%20%E6%8F%92%E4%BB%B6/"/>
      <url>/2019/06/02/%E7%88%AC%E8%99%AB%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%B8%B8%E7%94%A8%E7%9A%84%20Chrome%20%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>做多了爬虫都知道，写一个爬虫大部分时间不是在代码上，而是在分析网页上，所有有一套好用的工具可以极大节省劳动力，这里把平时积累的一些 Chrome 插件分享出来，均来自本人和同事推荐，并不定时更新，欢迎点赞和收藏。<br>下面大标题指向的是谷歌应用商店，访问需要特殊方法，也可以进入本仓库的 <code>extensions</code> 目录中下载。</p></blockquote><h2 id="XPath-Helper"><a href="#XPath-Helper" class="headerlink" title="XPath Helper"></a><a href="https://chrome.google.com/webstore/detail/xpath-helper/hgimnogjllphhhkhlmebbmlgjoejdpjl" target="_blank" rel="noopener">XPath Helper</a></h2><p><img src="https://static.zkqiang.cn/images/20190729094906.png-slim" alt="XPath Helper"></p><p>相比较 Chrome 自身的 html 搜索，这款插件好用之处是可以显示匹配结果，在插件里写出正确的 XPath 语句后再复制到代码里即可。</p><h2 id="Toggle-JavaScript"><a href="#Toggle-JavaScript" class="headerlink" title="Toggle JavaScript"></a><a href="https://chrome.google.com/webstore/detail/toggle-javascript/cidlcjdalomndpeagkjpnefhljffbnlo" target="_blank" rel="noopener">Toggle JavaScript</a></h2><p><img src="https://static.zkqiang.cn/images/20190729094907.png-slim" alt="Toggle JavaScript"></p><p>一键拦截网页所有的 JS，可以快速区分出哪些是异步加载的数据，绝对是爬虫必备神器。</p><h2 id="FeHelper"><a href="#FeHelper" class="headerlink" title="FeHelper"></a><a href="https://chrome.google.com/webstore/detail/web%E5%89%8D%E7%AB%AF%E5%8A%A9%E6%89%8Bfehelper/pkgccpejnmalmdinmhkkfafefagiiiad" target="_blank" rel="noopener">FeHelper</a></h2><p><img src="https://static.zkqiang.cn/images/20190729094903.png-slim" alt="FeHelper"></p><p>这款插件的强大之处不想多说，看上面的截图就行了，其中一些数据转换的功能，在分析请求时会经常用到。</p><h2 id="JSON-Handle"><a href="#JSON-Handle" class="headerlink" title="JSON-Handle"></a><a href="https://chrome.google.com/webstore/detail/json-handle/iahnhfdhidomcpggpaimmmahffihkfnj" target="_blank" rel="noopener">JSON-Handle</a></h2><p><img src="https://static.zkqiang.cn/images/20190729095522.png-slim" alt="JSON-Handle"></p><p>这是由知乎 @流沙 推荐的 JSON 格式化插件，虽然上面推荐的已经带有 JSON 功能，但这款插件带有局部选取、对象类型、数组长度等小功能，我试用了几天很实用，适合有额外需求的时候。</p><h2 id="User-Agent-Switcher"><a href="#User-Agent-Switcher" class="headerlink" title="User-Agent Switcher"></a><a href="https://chrome.google.com/webstore/detail/user-agent-switcher-for-c/djflhoibgkdhkhhcedjiklpkjnoahfmg" target="_blank" rel="noopener">User-Agent Switcher</a></h2><p><img src="https://static.zkqiang.cn/images/20190729094904.png-slim" alt="User-Agent Switcher"></p><p>快速修改 <code>UserAgent</code> 的插件，当需要请求移动端页面时，或者需要传特殊的 UA 时，不要忘记它。</p><h2 id="X-Forwarded-For-Header"><a href="#X-Forwarded-For-Header" class="headerlink" title="X-Forwarded-For Header"></a><a href="https://chrome.google.com/webstore/detail/x-forwarded-for-header/hkghghbnihliadkabmlcmcgmffllglin" target="_blank" rel="noopener">X-Forwarded-For Header</a></h2><p><img src="https://static.zkqiang.cn/images/20190729094902.png-slim" alt="X-Forwarded-For Header"></p><p>有时候网站过滤 IP 是通过请求 Headers 中的 <code>X-Forwarded-For</code> 字段，通过这个插件就可以修改此字段，用来快速进行判断。</p><h2 id="SwitchyOmega"><a href="#SwitchyOmega" class="headerlink" title="SwitchyOmega"></a><a href="https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif" target="_blank" rel="noopener">SwitchyOmega</a></h2><p><img src="https://static.zkqiang.cn/images/20190729094908.png-slim" alt="SwitchyOmega"></p><p>快速切换 HTTP / Socks 代理的插件，还能根据匹配地址自动切换。另一个技巧是配合 Charles、Burp Suite 这类抓包工具，这些工具使用时需要设置本地代理，可以提前设置好用时就切换。</p><h2 id="Wappalyzer"><a href="#Wappalyzer" class="headerlink" title="Wappalyzer"></a><a href="https://chrome.google.com/webstore/detail/wappalyzer/gppongmhjkpfnbhagpmjfkannfbllamg" target="_blank" rel="noopener">Wappalyzer</a></h2><p><img src="https://static.zkqiang.cn/images/20190811175102.png-slim" alt="Wappalyzer"></p><p>可以解析当前前端页面所使用的框架及服务支持，这样可以针对 Web 框架使用特殊的爬取方式。</p><h2 id="Web-Scraper"><a href="#Web-Scraper" class="headerlink" title="Web Scraper"></a><a href="https://chrome.google.com/webstore/detail/web-scraper/jnhgnonknehpejjnehehllkliplmbmhn" target="_blank" rel="noopener">Web Scraper</a></h2><p><img src="https://static.zkqiang.cn/images/20190811175103.png-slim" alt="Web Scraper"></p><p>又一个神器，如果只是简单的爬取数据，不需要部署和更复杂的操作，可以使用这款插件，内置在 Chrome 控制台，直接操作 Chrome 浏览器进行爬取，不需要写一行代码，支持多种导出格式。</p><h2 id="EditThisCookie"><a href="#EditThisCookie" class="headerlink" title="EditThisCookie"></a><a href="https://chrome.google.com/webstore/detail/editthiscookie/fngmhnnpilhplaeedifhccceomclgfbg" target="_blank" rel="noopener">EditThisCookie</a></h2><p><img src="https://static.zkqiang.cn/images/20190831161529.png-slim" alt="EditThisCookie"></p><p>爬虫遇到权限页面时，难免要对 Cookie 反复调试，这款插件可以对当前站点进行 Cookie 编辑，支持增删改查、导入导出、一键清空、搜索等功能。</p><h2 id="打包下载"><a href="#打包下载" class="headerlink" title="打包下载"></a>打包下载</h2><p>如果无法进入谷歌商店，可关注微信公众号：<strong>面向人生编程</strong> (可扫本页底部二维码)，回复”<strong>插件</strong>“获取打包下载。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫必备：Python 执行 JS 代码 —— PyExecJS、PyV8、Js2Py</title>
      <link href="/2019/03/18/%E7%88%AC%E8%99%AB%E5%BF%85%E5%A4%87%EF%BC%9APython%20%E6%89%A7%E8%A1%8C%20JS%20%E4%BB%A3%E7%A0%81%20%E2%80%94%E2%80%94%20PyExecJS%E3%80%81PyV8%E3%80%81Js2Py/"/>
      <url>/2019/03/18/%E7%88%AC%E8%99%AB%E5%BF%85%E5%A4%87%EF%BC%9APython%20%E6%89%A7%E8%A1%8C%20JS%20%E4%BB%A3%E7%A0%81%20%E2%80%94%E2%80%94%20PyExecJS%E3%80%81PyV8%E3%80%81Js2Py/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在使用爬虫中，经常会遇到网页请求数据是经过 JS 处理的，特别是模拟登录时可能有加密请求。而目前绝大部分前端 JS 代码都是经过混淆的，可读性极低，想理解代码逻辑需要花费大量时间。这时不要着急使用 Selenium 暴力解决，毕竟 Selenium 严重拖慢爬虫效率，我们可以尝试使用一些第三方库，来直接执行前端 JS 代码得到处理过后的结果。</p></blockquote><h2 id="PyExecJS"><a href="#PyExecJS" class="headerlink" title="PyExecJS"></a>PyExecJS</h2><p>这个库主要是将 JS 代码运行在本地的 JS 环境中，优点是我们有多种 JS 环境的选择，官方推荐了 PyV8、Node.js、PhantomJS、Nashorn 四种，当然缺点是必须安装一种环境导致不是很轻量，而且调用时有一个启动环境过程，还是有明显缓慢的。</p><h3 id="安装方式"><a href="#安装方式" class="headerlink" title="安装方式"></a>安装方式</h3><p>先解决 JS 环境，这里推荐安装 <a href="http://nodejs.cn/download/" target="_blank" rel="noopener">Node.js</a> ，安装方便，执行效率也高。<br>然后 <code>pip install PyExecJS</code> 就可以了。</p><h3 id="使用例子"><a href="#使用例子" class="headerlink" title="使用例子"></a>使用例子</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> execjs</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>execjs.get().name  <span class="comment"># 查看调用的环境</span></span><br><span class="line"><span class="string">'Node.js (V8)'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ctx = execjs.compile(<span class="string">"""  # 执行 JS 语句</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    function add(x, y) &#123;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>        return x + y;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    &#125;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>"""</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ctx.call(<span class="string">"add"</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> open(<span class="string">'./test.js'</span>) <span class="keyword">as</span> f:  <span class="comment"># 执行 JS 文件</span></span><br><span class="line"><span class="meta">... </span>    ctx = execjs.compile(f.read())</span><br><span class="line"><span class="meta">... </span>    ctx.call(<span class="string">'add'</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><h2 id="PyV8"><a href="#PyV8" class="headerlink" title="PyV8"></a>PyV8</h2><p>这是 Google 官方将 Chrome V8 引擎用 Python 封装的库，和 <code>PyExecJS</code> 相比，这个库很轻量，不需要额外装 JS 环境，因为 V8 本身就是环境，同时也因为不需要启动外部环境，执行速度很快。</p><h3 id="安装方式-1"><a href="#安装方式-1" class="headerlink" title="安装方式"></a>安装方式</h3><p>Python3 安装不要使用pip，因为官方只支持 Python2，需要在这里下载对应系统的二进制文件：<a href="https://github.com/emmetio/pyv8-binaries" target="_blank" rel="noopener">https://github.com/emmetio/pyv8-binaries</a><br>然后解压后将 PyV8.py 与 _PyV8.so (如so不是这个名字需要改成这样) 两文件复制到 Python 的 site-packages 目录下，如 <code>/usr/local/lib/python3.6/site-packages</code> 。</p><h3 id="使用例子-1"><a href="#使用例子-1" class="headerlink" title="使用例子"></a>使用例子</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> PyV8  <span class="comment"># 注意大小写</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> PyV8.JSContext() <span class="keyword">as</span> ctx:</span><br><span class="line"><span class="meta">... </span>    ctx.eval(<span class="string">"""</span></span><br><span class="line"><span class="string"><span class="meta">... </span>        function add(x, y) &#123;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>            return x + y;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>        &#125;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    """</span>)</span><br><span class="line"><span class="meta">... </span>    ctx.locals.add(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><h2 id="Js2Py"><a href="#Js2Py" class="headerlink" title="Js2Py"></a>Js2Py</h2><p>最后这个库，作用是将 JS 代码直接转译成 Python 代码，这种方式可以摆脱调用 JS 环境的瓶颈，但遗憾的是如果用于很长的混淆 JS 代码，转译过来的大概率会报错… 所以只建议先尝试一下，如果报错及时更换上面的库。</p><h3 id="安装方式-2"><a href="#安装方式-2" class="headerlink" title="安装方式"></a>安装方式</h3><p><code>pip install js2py</code></p><h3 id="使用例子-2"><a href="#使用例子-2" class="headerlink" title="使用例子"></a>使用例子</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> js2py</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add = js2py.eval_js(<span class="string">"""</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    function add(x, y) &#123;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>        return x + y;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    &#125;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>"""</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add  <span class="comment"># 可以看到大括号里已被转译</span></span><br><span class="line"><span class="string">'function add(x, y) &#123; [python code] &#125;'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 使用下边这个方法可以输出转译后的代码</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 可以保存到文件里，下次不需要再次转译</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(js2py.translate_js(<span class="string">'var x = 1'</span>))</span><br><span class="line"><span class="keyword">from</span> js2py.pyjs <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># setting scope</span></span><br><span class="line">var = Scope( JS_BUILTINS )</span><br><span class="line">set_global_object(var)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Code follows:</span></span><br><span class="line">var.registers([<span class="string">'x'</span>])</span><br><span class="line">var.put(<span class="string">'x'</span>, Js(<span class="number">1.0</span>))</span><br></pre></td></tr></table></figure><h2 id="实战技巧"><a href="#实战技巧" class="headerlink" title="实战技巧"></a>实战技巧</h2><p>当选择完合适的库后，如果你还不明白在浏览器里进行 Debug 的方法，那需要去搜索关键词先学习一下。</p><p>接下来就是定位目标网页需要调用的 JS 函数，这里实在无法详述，因为每个网站的写法都大不相同。</p><p>不过只要你通过 Debug ，查看数据从请求开始，每一步都经过了哪些 JS 函数，又输出成什么样的数据，就可以顺藤摸瓜找到一些可疑的函数，然后将这些方法逐一复制出来，通过上面的库传入参数执行，看是否和目标网页处理后的数据一致，就可以找到目标函数。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 简单进行简繁转换</title>
      <link href="/2019/01/29/Python%20%E7%AE%80%E5%8D%95%E8%BF%9B%E8%A1%8C%E7%AE%80%E7%B9%81%E8%BD%AC%E6%8D%A2/"/>
      <url>/2019/01/29/Python%20%E7%AE%80%E5%8D%95%E8%BF%9B%E8%A1%8C%E7%AE%80%E7%B9%81%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p>最近项目中用到了简单的简繁转换，如果用<code>OpenCC</code>太重了，于是搜到了 <a href="https://github.com/gumblex/zhconv" target="_blank" rel="noopener">zhconv</a> 这个库。</p><p><strong>zhconv</strong> 提供基于 MediaWiki 词汇表的最大正向匹配简繁转换，Python 2, 3 通用。</p><p>支持以下地区词转换：</p><ul><li><p><code>zh-tw</code> 台灣正體</p></li><li><p><code>zh-hk</code> 香港繁體</p></li><li><p><code>zh-sg</code> 马新简体</p></li><li><p><code>zh-hans</code> 简体</p></li><li><p><code>zh-hant</code> 繁體</p></li></ul><p>正好适合我不求转换质量的轻量需求，所以介绍给更多需要的人。</p><p>而且虽然该项目stars很少，但中途发现作者还参与过维护jieba分词。</p><p>调用也非常简单</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">from</span> zhconv <span class="keyword">import</span> convert</span><br><span class="line">&gt;&gt;&gt; convert(<span class="string">'Python是一种动态的、面向对象的脚本语言'</span>, <span class="string">'zh-hant'</span>)</span><br><span class="line"><span class="string">'Python是一種動態的、面向對象的腳本語言'</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>支持对地区化词语的转换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; convert(<span class="string">'计算机软件'</span>, <span class="string">'zh-tw'</span>)</span><br><span class="line"><span class="string">'計算機軟體'</span></span><br><span class="line">&gt;&gt;&gt; convert(<span class="string">'計算機軟體'</span>, <span class="string">'zh-hans'</span>) <span class="comment"># zh-hans只是逐字转换</span></span><br><span class="line"><span class="string">'计算机软体'</span></span><br><span class="line">&gt;&gt;&gt; convert(<span class="string">'計算機軟體'</span>, <span class="string">'zh-cn'</span>)</span><br><span class="line"><span class="string">'计算机软件'</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>支持 MediaWiki 人工转换语法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">from</span> zhconv <span class="keyword">import</span> convert\_for\_mw</span><br><span class="line">&gt;&gt;&gt; s = <span class="string">'張國榮曾在英國-&#123;zh:利兹;zh-hans:利兹;zh-hk:列斯;zh-tw:里茲&#125;-大学學習。'</span></span><br><span class="line">&gt;&gt;&gt; convert\_for\_mw(s, <span class="string">'zh-hans'</span>)</span><br><span class="line"><span class="string">'张国荣曾在英国利兹大学学习。'</span></span><br><span class="line">&gt;&gt;&gt; convert\_for\_mw(s, <span class="string">'zh-hk'</span>)</span><br><span class="line"><span class="string">'張國榮曾在英國列斯大學學習。'</span></span><br><span class="line">&gt;&gt;&gt; convert\_for\_mw(s, <span class="string">'zh-tw'</span>)</span><br><span class="line"><span class="string">'張國榮曾在英國里茲大學學習。'</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>当然对于复杂高精度的转换需求，还是建议用专业的<code>OpenCC</code> 开源库：</p><p><a href="https://github.com/BYVoid/OpenCC" target="_blank" rel="noopener">https://github.com/BYVoid/OpenCC</a>  </p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 输出命令行进度条</title>
      <link href="/2018/12/29/Python%20%E8%BE%93%E5%87%BA%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BF%9B%E5%BA%A6%E6%9D%A1/"/>
      <url>/2018/12/29/Python%20%E8%BE%93%E5%87%BA%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BF%9B%E5%BA%A6%E6%9D%A1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在使用 pip 安装时，你会发现有下载进度条，我们也可以借助开源的第三方库来实现这个功能，在项目输出时增加一些可视化效果。</p></blockquote><p>一个简单易用的第三方库是：<a href="https://github.com/verigak/progress" target="_blank" rel="noopener">progress</a></p><p>作者提供了动图很直观地展现了实现的所有输出。</p><p><img src="https://camo.githubusercontent.com/2eac4822edcfe3353ad2e4b56c33b6e4b4f8955f/68747470733a2f2f7261772e6769746875622e636f6d2f7665726967616b2f70726f67726573732f6d61737465722f64656d6f2e676966" alt="image"></p><p>这个库实现了两类样式，一类是有终点的进度条样式，另一类是多用于加载的转圈样式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> progress.bar <span class="keyword">import</span> Bar</span><br><span class="line"></span><br><span class="line">bar = Bar(<span class="string">'Processing'</span>, max=<span class="number">100</span>, fill=<span class="string">'@'</span>, suffix=<span class="string">'%(percent)d%%'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">    time.sleep(<span class="number">0.1</span>)</span><br><span class="line">    bar.next()</span><br><span class="line">bar.finish()</span><br></pre></td></tr></table></figure><p>参数定义的功能：</p><ul><li>max：进度条最大进度</li><li>fill：进度条填充的字符</li><li>suffix：百分比的样式</li></ul><p>运行上述代码会得到输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Processing |@@@@@@                          | 20%</span><br></pre></td></tr></table></figure><p>同时也提供上下文的用法（需要用 Github 里的源代码）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> Bar(<span class="string">'Processing'</span>, max=<span class="number">20</span>) <span class="keyword">as</span> bar:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">        <span class="comment"># Do some work</span></span><br><span class="line">        bar.next()</span><br></pre></td></tr></table></figure><p>另一类转圈样式，用法和<code>Bar</code>类似，只要没达到终点就一直调用<code>next</code>方法即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> progress.spinner <span class="keyword">import</span> Spinner</span><br><span class="line"></span><br><span class="line">spinner = Spinner(<span class="string">'Loading '</span>)</span><br><span class="line"><span class="keyword">while</span> state != <span class="string">'FINISHED'</span>:</span><br><span class="line">    <span class="comment"># Do some work</span></span><br><span class="line">    spinner.next()</span><br></pre></td></tr></table></figure><p>动图里的所有样式都是作者已经实现的派生类，用法基本都一样，当然也可以继承基础类来自己实现更多的功能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SlowBar</span><span class="params">(Bar)</span>:</span></span><br><span class="line">    suffix = <span class="string">'%(remaining_hours)d hours remaining'</span></span><br><span class="line">    @property</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remaining_hours</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.eta // <span class="number">3600</span></span><br></pre></td></tr></table></figure><hr><p>上面介绍的库，实现的功能很简单，而且默认只能输出到终端。</p><p>如果有更复杂的使用场景，推荐使用另一个库：<a href="https://github.com/WoLpH/python-progressbar" target="_blank" rel="noopener">python-progressbar</a></p><p>这个库实现了更多功能，可以自定义组合出一个进度条样式，还可以指定输出流。</p><p>基本的使用很简单，可以直接传入迭代对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> progressbar</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> progressbar.progressbar(range(<span class="number">100</span>)):</span><br><span class="line">    time.sleep(<span class="number">0.02</span>)</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">70% (70 of 100) |################       | Elapsed Time: 0:00:01 ETA:   0:00:00</span><br></pre></td></tr></table></figure><p>也可以生成对象后调用<code>update</code>方法 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> progressbar</span><br><span class="line"></span><br><span class="line">bar = progressbar.ProgressBar(max_value=<span class="number">100</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">    time.sleep(<span class="number">0.1</span>)</span><br><span class="line">    bar.update(i)</span><br></pre></td></tr></table></figure><p>最有特点之处就是可以自定义组件，比如我们来实现类似于动图中转圈加载的样式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> progressbar</span><br><span class="line"></span><br><span class="line">widgets = \[</span><br><span class="line">    <span class="string">'Loading: '</span>,</span><br><span class="line">    <span class="string">'\['</span>, progressbar.AnimatedMarker(), <span class="string">'\]'</span>,</span><br><span class="line">    <span class="string">' '</span>,</span><br><span class="line">    progressbar.Timer()</span><br><span class="line">\]</span><br><span class="line">bar = progressbar.ProgressBar(</span><br><span class="line">    widgets=widgets, max_value=progressbar.UnknownLength)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">    time.sleep(<span class="number">0.5</span>)</span><br><span class="line">    bar.update(i)</span><br></pre></td></tr></table></figure><p>输出样式是这样的，方括号中的会一直旋转</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Loading: \[\\\] Elapsed Time: 0:00:13</span><br></pre></td></tr></table></figure><p>更多功能不再赘述，可以查看 GitHub 中的文档</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自学入门 Python 优质中文资源索引</title>
      <link href="/2018/11/14/%E8%87%AA%E5%AD%A6%E5%85%A5%E9%97%A8%20Python%20%E4%BC%98%E8%B4%A8%E4%B8%AD%E6%96%87%E8%B5%84%E6%BA%90%E7%B4%A2%E5%BC%95/"/>
      <url>/2018/11/14/%E8%87%AA%E5%AD%A6%E5%85%A5%E9%97%A8%20Python%20%E4%BC%98%E8%B4%A8%E4%B8%AD%E6%96%87%E8%B5%84%E6%BA%90%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>所有资源基于 Python3 版本，全部中文内容，适用于 爬虫 / Web / 数据 方向，每个单元根据学习习惯从 书籍 / 文档 / 视频 中选择一类即可，建议任选一本书籍，然后配合文档类进行学习。<br>资源遵守“宁缺毋滥”的原则，均经过网评筛选或个人亲测，不推荐各类低质量大杂烩的文章书籍，力求少走弯路。<br>通过本文链接资源坚持学习，可真正的零基础自学入门 Python ，实测已帮助两位零编程基础的朋友入门。<br>本索引清单将长期更新，更替更好的资源，请收藏的同时别忘了点个赞！也欢迎通过私信等方式补充推荐。</p></blockquote><h2 id="1-1-语言基础"><a href="#1-1-语言基础" class="headerlink" title="1.1 语言基础"></a>1.1 语言基础</h2><h4 id="书籍类（任选"><a href="#书籍类（任选" class="headerlink" title="书籍类（任选)"></a>书籍类（任选)</h4><p><a href="https://item.jd.com/11993134.html?cu=true&utm_source=kong&utm_medium=tuiguang&utm_campaign=t_1001542270_1000008160_0_1929571479&utm_term=3a5041eb2363478d977b6ce59798dcc2" target="_blank" rel="noopener">Python 编程：从入门到实践</a><br><a href="https://item.jd.com/12202703.html?cu=true&utm_source=kong&utm_medium=tuiguang&utm_campaign=t_1001542270_1000008160_0_1929571479&utm_term=281a2ca3f6a74137b27bb9a8b171b61c" target="_blank" rel="noopener">Python 游戏编程快速上手 – 通过游戏趣味入门</a><br><a href="https://item.jd.com/10062788.html?cu=true&utm_source=kong&utm_medium=tuiguang&utm_campaign=t_1001542270_1000008160_0_1929571479&utm_term=3386f9ebe12c46ffb44e4a9c494004aa" target="_blank" rel="noopener">Python 核心编程 – 适合有编程基础</a>  </p><h4 id="视频类（任选）"><a href="#视频类（任选）" class="headerlink" title="视频类（任选）"></a>视频类（任选）</h4><p><a href="https://www.bilibili.com/video/av27789609" target="_blank" rel="noopener">小甲鱼零基础入门 Python</a><br><a href="https://www.icourse163.org/course/BIT-268001" target="_blank" rel="noopener">Python 语言程序设计_北京理工大学_中国大学 MOOC</a>  </p><h4 id="文档类（任选）"><a href="#文档类（任选）" class="headerlink" title="文档类（任选）"></a>文档类（任选）</h4><p><a href="http://www.runoob.com/python3/python3-tutorial.html" target="_blank" rel="noopener">菜鸟教程 — 适合零基础</a><br><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000" target="_blank" rel="noopener">廖雪峰教程 — 适合有编程基础</a><br><a href="https://yiyibooks.cn/xx/python_352/index.html" target="_blank" rel="noopener">官方文档翻译 — 适合其他语言转学</a>  </p><hr><h2 id="1-2-语言进阶"><a href="#1-2-语言进阶" class="headerlink" title="1.2 语言进阶"></a>1.2 语言进阶</h2><h4 id="书籍类（任选-1"><a href="#书籍类（任选-1" class="headerlink" title="书籍类（任选)"></a>书籍类（任选)</h4><p><a href="https://item.jd.com/12186192.html?cu=true&utm_source=kong&utm_medium=tuiguang&utm_campaign=t_1001542270_1000008160_0_1929571479&utm_term=b13a193f9b934ac5a3d91bb5b338c120" target="_blank" rel="noopener">流畅的 Python – 必读经典</a><br><a href="https://item.jd.com/11681561.html?cu=true&utm_source=kong&utm_medium=tuiguang&utm_campaign=t_1001542270_1000008160_0_1929571479&utm_term=cd8772417e5a43fd91e4ef3f69e65527" target="_blank" rel="noopener">Python Cookbook – 必读经典</a><br><a href="https://item.jd.com/12336391.html?cu=true&utm_source=kong&utm_medium=tuiguang&utm_campaign=t_1001542270_1000008160_0_1929571479&utm_term=9464e258ce0546cba144091d8fdfb4f6" target="_blank" rel="noopener">图解数据结构 Python 版</a><br><a href="https://item.jd.com/12385123.html?cu=true&utm_source=kong&utm_medium=tuiguang&utm_campaign=t_1001542270_1000008160_0_1929571479&utm_term=78fedcb68cba49d681fa7590b62fe954" target="_blank" rel="noopener">Python 3 面向对象编程 – Web开发必读</a>  </p><hr><h2 id="2-1-爬虫基础"><a href="#2-1-爬虫基础" class="headerlink" title="2.1 爬虫基础"></a>2.1 爬虫基础</h2><h4 id="书籍类（任选）"><a href="#书籍类（任选）" class="headerlink" title="书籍类（任选）"></a>书籍类（任选）</h4><p><a href="https://item.jd.com/1179243750.html?cu=true&utm_source=kong&utm_medium=tuiguang&utm_campaign=t_1001542270_1000008160_0_1929571479&utm_term=fd56d83454434af7953d5d0df0c2c5bf" target="_blank" rel="noopener">图解HTTP — 零基础必读</a><br><a href="https://item.jd.com/49825026628.html?cu=true&utm_source=kong&utm_medium=tuiguang&utm_campaign=t_1001542270_1000008160_0_1929571479&utm_term=c5522372b8fb464dbb98a26ec96aae36" target="_blank" rel="noopener">Python3 网络爬虫开发实战 – 必读</a><br><a href="https://item.jd.com/45942848920.html?cu=true&utm_source=kong&utm_medium=tuiguang&utm_campaign=t_1001542270_1000008160_0_1929571479&utm_term=7e35b89bfe3f41189ecb222c7f111a50" target="_blank" rel="noopener">Android软件安全权威指南 – 爬虫逆向进阶</a>  </p><h4 id="视频类（全学）"><a href="#视频类（全学）" class="headerlink" title="视频类（全学）"></a>视频类（全学）</h4><p><a href="https://www.icourse163.org/course/BIT-1001870001" target="_blank" rel="noopener">Python 网络爬虫与信息提取_北京理工大学_中国大学MOOC</a><br><a href="https://edu.hellobi.com/course/157" target="_blank" rel="noopener">零基础入门 Python3 爬虫_崔庆才</a></p><h4 id="文档类（全学）"><a href="#文档类（全学）" class="headerlink" title="文档类（全学）"></a>文档类（全学）</h4><p><a href="http://www.ruanyifeng.com/blog/2016/08/http.html" target="_blank" rel="noopener">HTTP 协议入门_阮一峰 — 零基础必读</a><br><a href="http://docs.python-requests.org/zh_CN/latest/user/quickstart.html" target="_blank" rel="noopener">Requests 官方文档翻译</a><br><a href="https://beautifulsoup.readthedocs.io/zh_CN/latest/" target="_blank" rel="noopener">Beautiful Soup 官方文档翻译</a><br><a href="https://www.cnblogs.com/huxi/archive/2010/07/04/1771073.html" target="_blank" rel="noopener">Python 正则表达式指南</a><br><a href="http://www.w3school.com.cn/xpath/index.asp" target="_blank" rel="noopener">XPath 教程</a><br><a href="https://scrapy-chs.readthedocs.io/zh_CN/1.0/intro/install.html" target="_blank" rel="noopener">Scrapy 官方文档翻译</a><br><a href="https://selenium-python-zh.readthedocs.io/en/latest/index.html" target="_blank" rel="noopener">Selenium-Python 官方文档翻译</a></p><hr><h2 id="2-2-Flask-框架"><a href="#2-2-Flask-框架" class="headerlink" title="2.2 Flask 框架"></a>2.2 Flask 框架</h2><h4 id="书籍类（任选）-1"><a href="#书籍类（任选）-1" class="headerlink" title="书籍类（任选）"></a>书籍类（任选）</h4><p><a href="https://item.jd.com/1179243750.html?cu=true&utm_source=kong&utm_medium=tuiguang&utm_campaign=t_1001542270_1000008160_0_1929571479&utm_term=fd56d83454434af7953d5d0df0c2c5bf" target="_blank" rel="noopener">图解HTTP — 零基础必读</a><br><a href="https://item.jd.com/32885183767.html?cu=true&utm_source=kong&utm_medium=tuiguang&utm_campaign=t_1001542270_1000008160_0_1929571479&utm_term=f286c6172dbd4b02b2e1ce1725e7fddd" target="_blank" rel="noopener">Flask Web开发实战（狼书） – 必读，Flask 核心开发创作</a>  </p><h4 id="文档类（全学）-1"><a href="#文档类（全学）-1" class="headerlink" title="文档类（全学）"></a>文档类（全学）</h4><p><a href="http://www.ruanyifeng.com/blog/2016/08/http.html" target="_blank" rel="noopener">HTTP 协议入门_阮一峰 — 零基础必读</a><br><a href="http://docs.jinkan.org/docs/flask/" target="_blank" rel="noopener">Flask 官方文档翻译</a><br><a href="http://helloflask.com/tutorial/" target="_blank" rel="noopener">Flask 入门教程 – 强推，Flask 核心开发创作</a><br><a href="http://www.pythondoc.com/flask-mega-tutorial/" target="_blank" rel="noopener">Flask mega-tutorial 中文翻译 — Web微框架指南</a><br><a href="http://docs.jinkan.org/docs/jinja2/" target="_blank" rel="noopener">Jinja2 官方文档翻译</a>  </p><hr><h2 id="2-3-Django-框架"><a href="#2-3-Django-框架" class="headerlink" title="2.3 Django 框架"></a>2.3 Django 框架</h2><h4 id="书籍类（任选）-2"><a href="#书籍类（任选）-2" class="headerlink" title="书籍类（任选）"></a>书籍类（任选）</h4><p><a href="https://item.jd.com/1179243750.html?cu=true&utm_source=kong&utm_medium=tuiguang&utm_campaign=t_1001542270_1000008160_0_1929571479&utm_term=fd56d83454434af7953d5d0df0c2c5bf" target="_blank" rel="noopener">图解HTTP — 零基础必读</a><br><a href="https://item.jd.com/12537842.html?cu=true&utm_source=kong&utm_medium=tuiguang&utm_campaign=t_1001542270_1000008160_0_1929571479&utm_term=e74f4a006d274bfd9ff0a039609208c9" target="_blank" rel="noopener">Django企业开发实战</a>  </p><h4 id="文档类（全学）-2"><a href="#文档类（全学）-2" class="headerlink" title="文档类（全学）"></a>文档类（全学）</h4><p><a href="http://www.ruanyifeng.com/blog/2016/08/http.html" target="_blank" rel="noopener">HTTP 协议入门_阮一峰 — 零基础必读</a><br><a href="https://docs.djangoproject.com/zh-hans/3.0/" target="_blank" rel="noopener">Django 3.0 官方文档</a>  </p><hr><h2 id="2-4-Web-前端"><a href="#2-4-Web-前端" class="headerlink" title="2.4 Web 前端"></a>2.4 Web 前端</h2><h4 id="书籍类（任选）-3"><a href="#书籍类（任选）-3" class="headerlink" title="书籍类（任选）"></a>书籍类（任选）</h4><p><a href="https://item.jd.com/11090963.html?cu=true&utm_source=kong&utm_medium=tuiguang&utm_campaign=t_1001542270_1000008160_0_1929571479&utm_term=805b7ab7e7a4406e97af470023f41dd5" target="_blank" rel="noopener">JavaScript 语言精粹（修订版）</a><br><a href="https://item.jd.com/49883132371.html?cu=true&utm_source=kong&utm_medium=tuiguang&utm_campaign=t_1001542270_1000008160_0_1929571479&utm_term=518dad27c6e24318be217ac6391b7a74" target="_blank" rel="noopener">CSS 揭秘</a><br><a href="https://item.jd.com/12517946.html?cu=true&utm_source=kong&utm_medium=tuiguang&utm_campaign=t_1001542270_1000008160_0_1929571479&utm_term=a6ed70c74a5949c28719ee3c824e387e" target="_blank" rel="noopener">Vue.js 快速入门</a><br><a href="https://item.jd.com/12068636.html?cu=true&utm_source=kong&utm_medium=tuiguang&utm_campaign=t_1001542270_1000008160_0_1929571479&utm_term=8bee6545d5b644309bcfe96fd755c41d" target="_blank" rel="noopener">深入 React 技术栈</a>  </p><h4 id="文档类（全学）-3"><a href="#文档类（全学）-3" class="headerlink" title="文档类（全学）"></a>文档类（全学）</h4><p><a href="http://www.w3school.com.cn/js/index.asp" target="_blank" rel="noopener">JavaScript 教程</a><br><a href="https://cn.vuejs.org/v2/guide/index.html" target="_blank" rel="noopener">Vue.js 官方中文文档</a><br><a href="https://www.reactjscn.com/docs/hello-world.html" target="_blank" rel="noopener">React 官方文档</a><br><a href="https://www.tslang.cn/docs/home.html" target="_blank" rel="noopener">TypeScript 官方文档</a>  </p><hr><h2 id="2-5-数据分析"><a href="#2-5-数据分析" class="headerlink" title="2.5 数据分析"></a>2.5 数据分析</h2><h4 id="书籍类（任选）-4"><a href="#书籍类（任选）-4" class="headerlink" title="书籍类（任选）"></a>书籍类（任选）</h4><p><a href="https://item.jd.com/29428299573.html?cu=true&utm_source=kong&utm_medium=tuiguang&utm_campaign=t_1001542270_1000008160_0_1929571479&utm_term=81d3ab8edd92497c9f654e9207e75dff" target="_blank" rel="noopener">Python 数据科学手册</a><br><a href="https://item.jd.com/12398725.html?cu=true&utm_source=kong&utm_medium=tuiguang&utm_campaign=t_1001542270_1000008160_0_1929571479&utm_term=f0e26ff1309a432a8bec157e32638e09" target="_blank" rel="noopener">利用 Python 进行数据分析</a>  </p><h4 id="文档类（全学）-4"><a href="#文档类（全学）-4" class="headerlink" title="文档类（全学）"></a>文档类（全学）</h4><p><a href="https://www.jianshu.com/p/62f155eb6ac5" target="_blank" rel="noopener">Anaconda 教程</a><br><a href="https://blog.csdn.net/DataCastle/article/details/78890469" target="_blank" rel="noopener">Jupyter Notebook 教程</a><br><a href="https://www.numpy.org.cn/" target="_blank" rel="noopener">NumPy 官方文档翻译</a><br><a href="https://www.yiibai.com/pandas/python_pandas_environment_setup.html" target="_blank" rel="noopener">Pandas 教程</a><br><a href="https://github.com/BrambleXu/pydata-notebook?utm_medium=social&utm_source=qq" target="_blank" rel="noopener">利用Python进行数据分析 中文翻译笔记</a>  </p><hr><h2 id="2-6-机器学习"><a href="#2-6-机器学习" class="headerlink" title="2.6 机器学习"></a>2.6 机器学习</h2><h4 id="书籍类（任选）-5"><a href="#书籍类（任选）-5" class="headerlink" title="书籍类（任选）"></a>书籍类（任选）</h4><p><a href="https://item.jd.com/11867803.html?cu=true&utm_source=kong&utm_medium=tuiguang&utm_campaign=t_1001542270_1000008160_0_1929571479&utm_term=2f2a53c477cd4c2f84a3a2cf70a222f6" target="_blank" rel="noopener">机器学习 (西瓜书)</a><br><a href="https://item.jd.com/12128543.html?cu=true&utm_source=kong&utm_medium=tuiguang&utm_campaign=t_1001542270_1000008160_0_1929571479&utm_term=c4343287898b4740b16ab2f5f60edbb2" target="_blank" rel="noopener">机器学习实战</a>  </p><h4 id="视频类（任选）-1"><a href="#视频类（任选）-1" class="headerlink" title="视频类（任选）"></a>视频类（任选）</h4><p><a href="https://study.163.com/course/courseMain.htm?courseId=1004570029" target="_blank" rel="noopener">吴恩达机器学习 - 网易云课堂 — 免费 必学</a>  </p><h4 id="文档类（任选）-1"><a href="#文档类（任选）-1" class="headerlink" title="文档类（任选）"></a>文档类（任选）</h4><p><a href="https://github.com/fengdu78/Coursera-ML-AndrewNg-Notes" target="_blank" rel="noopener">吴恩达机器学习笔记 — 相当于视频的文字版</a>  </p><hr><h2 id="3-数据库"><a href="#3-数据库" class="headerlink" title="3. 数据库"></a>3. 数据库</h2><h4 id="书籍类（任选）-6"><a href="#书籍类（任选）-6" class="headerlink" title="书籍类（任选）"></a>书籍类（任选）</h4><p><a href="https://item.jd.com/11220393.html?cu=true&utm_source=kong&utm_medium=tuiguang&utm_campaign=t_1001542270_1000008160_0_1929571479&utm_term=da846dfe1fa14db6a18bf1bed15e3869" target="_blank" rel="noopener">高性能 MySQL</a><br><a href="https://item.jd.com/11384782.html?cu=true&utm_source=kong&utm_medium=tuiguang&utm_campaign=t_1001542270_1000008160_0_1929571479&utm_term=0c7bacdc0b25430eb1a1ae9c486f3f15" target="_blank" rel="noopener">MongoDB 权威指南</a><br><a href="https://item.jd.com/11486101.html?cu=true&utm_source=kong&utm_medium=tuiguang&utm_campaign=t_1001542270_1000008160_0_1929571479&utm_term=940b141ea7bb4374a4eba79f6dee4d07" target="_blank" rel="noopener">Redis 设计与实现</a>  </p><h4 id="文档类（全学）-5"><a href="#文档类（全学）-5" class="headerlink" title="文档类（全学）"></a>文档类（全学）</h4><p><a href="http://www.runoob.com/redis/redis-tutorial.html" target="_blank" rel="noopener">Redis 教程</a><br><a href="http://www.w3school.com.cn/sql/index.asp" target="_blank" rel="noopener">SQL 教程</a><br><a href="https://www.jianshu.com/p/0ad18fdd7eed" target="_blank" rel="noopener">SQLAlchemy 教程</a><br><a href="http://www.mongoing.com/docs/" target="_blank" rel="noopener">MongoDB 官方中文文档 — 爬虫优先</a><br><a href="https://www.cnblogs.com/zhouxuchen/p/5544227.html" target="_blank" rel="noopener">PyMongo 官方文档部分翻译 — 爬虫优先</a>  </p><hr><h2 id="4-异步IO"><a href="#4-异步IO" class="headerlink" title="4. 异步IO"></a>4. 异步IO</h2><h4 id="文档类（任选）-2"><a href="#文档类（任选）-2" class="headerlink" title="文档类（任选）"></a>文档类（任选）</h4><p><a href="https://zhuanlan.zhihu.com/p/25228075" target="_blank" rel="noopener">从0到1，Python异步编程的演进之路 — 强烈推荐</a><br><a href="http://python.jobbole.com/88291/" target="_blank" rel="noopener">深入理解 Python 异步编程 — 可惜只有上篇</a><br><a href="https://www.jianshu.com/p/b5e347b3a17c" target="_blank" rel="noopener">Python 黑魔法 之 asyncio 协程</a><br><a href="http://demo.pythoner.com/itt2zh/index.html" target="_blank" rel="noopener">Introduction to Tornado 中文翻译</a><br><a href="https://blog.csdn.net/u010159842/article/details/56480219" target="_blank" rel="noopener">Gevent 开发指南</a><br><a href="https://likebeta.gitbooks.io/twisted-intro-cn/content/zh/" target="_blank" rel="noopener">Twisted与异步编程入门 — Scrapy爬虫进阶</a>  </p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>打印 Python 的一切 —— pprint &amp; beeprint</title>
      <link href="/2018/10/20/%E6%89%93%E5%8D%B0%20Python%20%E7%9A%84%E4%B8%80%E5%88%87%20%E2%80%94%E2%80%94%20pprint%20&amp;%20beeprint/"/>
      <url>/2018/10/20/%E6%89%93%E5%8D%B0%20Python%20%E7%9A%84%E4%B8%80%E5%88%87%20%E2%80%94%E2%80%94%20pprint%20&amp;%20beeprint/</url>
      
        <content type="html"><![CDATA[<blockquote><p>打印，是所有程序员从小白时期就具备的神技，遇事不决打印一下，是 DEBUG 最简单且不依赖 IDE 的方式，自定义各种日志输出，也是项目成型后必备功能。<br>但是为了优雅的打印格式，往往需要对各种对象进行特殊格式化，可遇到字典和大段字符串也不好处理。<br>这篇文章介绍两个库模块，可以快速有效的解决所有 Python 对象的打印输出，没错，所有。</p></blockquote><h2 id="pprint"><a href="#pprint" class="headerlink" title="pprint"></a><strong>pprint</strong></h2><p>这是 Python 标准库模块，全称 pretty printer，可以让各种数据结构更美观地输出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(game)</span><br><span class="line">&#123;&#39;players&#39;: \[&#123;&#39;name&#39;: &#39;player\_1&#39;, &#39;hp&#39;: 3&#125;, &#123;&#39;name&#39;: &#39;player\_2&#39;, &#39;hp&#39;: 5&#125;\]&#125;</span><br><span class="line">&gt;&gt;&gt; pprint.pprint(game, width&#x3D;4)</span><br><span class="line">&#123;&#39;players&#39;: \[&#123;&#39;hp&#39;: 3,</span><br><span class="line">              &#39;name&#39;: &#39;player_1&#39;&#125;,</span><br><span class="line">             &#123;&#39;hp&#39;: 5,</span><br><span class="line">              &#39;name&#39;: &#39;player_2&#39;&#125;\]&#125;</span><br></pre></td></tr></table></figure><p><code>pprint.pprint</code>(<em>object</em>, <em>stream=None</em>, <em>indent=1</em>, <em>width=80</em>, <em>depth=None</em>, <em>*</em>, <em>compact=False</em>)</p><ul><li><p>stream：输出流，默认是 sys.stdout ，也就是屏幕输出。</p></li><li><p>indent：缩进空格数。</p></li><li><p>width：每行最大宽度，默认为80个字符，超过宽度会换行，但如果单个对象超过不会被换行，比如一段长字符串。</p></li><li><p>depth：限制数据的层级，设置后可以限制过多的嵌套。</p></li><li><p>compact：3.4版本新加入的参数，若设为 True ，则输出会在接近 width 限制才进行换行。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; pprint.pprint(stuff, indent&#x3D;4)</span><br><span class="line">\[   \[&#39;spam&#39;, &#39;eggs&#39;, &#39;lumberjack&#39;, &#39;knights&#39;, &#39;ni&#39;\],</span><br><span class="line">    &#39;spam&#39;,</span><br><span class="line">    &#39;eggs&#39;,</span><br><span class="line">    &#39;lumberjack&#39;,</span><br><span class="line">    &#39;knights&#39;,</span><br><span class="line">    &#39;ni&#39;\]</span><br><span class="line">&gt;&gt;&gt; pprint.pprint(stuff, width&#x3D;41, compact&#x3D;True)</span><br><span class="line">\[\[&#39;spam&#39;, &#39;eggs&#39;, &#39;lumberjack&#39;,</span><br><span class="line">  &#39;knights&#39;, &#39;ni&#39;\],</span><br><span class="line"> &#39;spam&#39;, &#39;eggs&#39;, &#39;lumberjack&#39;, &#39;knights&#39;,</span><br><span class="line"> &#39;ni&#39;\]</span><br></pre></td></tr></table></figure><p><code>pprint.pformat</code>(<em>object</em>, <em>indent=1</em>, <em>width=80</em>, <em>depth=None</em>, <em>*</em>, <em>compact=False</em>)</p><p>和 <code>pprint.pprint</code> 的区别是，该函数不会打印到输出流，而是返回一个格式化字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; stuff &#x3D; \[&#39;spam&#39;, &#39;eggs&#39;, &#39;lumberjack&#39;, &#39;knights&#39;, &#39;ni&#39;\]</span><br><span class="line">&gt;&gt;&gt; stuff.insert(0, stuff)</span><br><span class="line">&gt;&gt;&gt; pprint.pprint(stuff)</span><br><span class="line">\[&lt;Recursion on list with id&#x3D;...&gt;,</span><br><span class="line"> &#39;spam&#39;,</span><br><span class="line"> &#39;eggs&#39;,</span><br><span class="line"> &#39;lumberjack&#39;,</span><br><span class="line"> &#39;knights&#39;,</span><br><span class="line"> &#39;ni&#39;\]</span><br></pre></td></tr></table></figure><p><em>class_<code>pprint.PrettyPrinter</code>(_indent=1</em>, <em>width=80</em>, <em>depth=None</em>, <em>stream=None</em>, <em>*</em>, <em>compact=False</em>)</p><p>上文两个函数，实际都是构建一个 <code>PrettyPrinter</code> 对象，并调用对应的方法，所以当需要复用格式化的时候，我们可以提前构建该对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; pp &#x3D; pprint.PrettyPrinter(width&#x3D;40, compact&#x3D;True)</span><br><span class="line">&gt;&gt;&gt; pp.pprint(game)</span><br><span class="line">&#123;&#39;players&#39;: \[&#123;&#39;hp&#39;: 3,</span><br><span class="line">              &#39;name&#39;: &#39;player_1&#39;&#125;,</span><br><span class="line">             &#123;&#39;hp&#39;: 5,</span><br><span class="line">              &#39;name&#39;: &#39;player_2&#39;&#125;\]&#125;</span><br><span class="line">&gt;&gt;&gt; pp.pprint(stuff)</span><br><span class="line">\[&#39;spam&#39;, &#39;eggs&#39;, &#39;lumberjack&#39;,</span><br><span class="line"> &#39;knights&#39;, &#39;ni&#39;\]</span><br></pre></td></tr></table></figure><p>更多用法可以参考官方文档：</p><p><a href="https://docs.python.org/3.5/library/pprint.html" target="_blank" rel="noopener">8.11. pprint - Data pretty printer - Python 3.5.6 documentationdocs.python.org</a></p><hr><p><code>pprint</code> 对字典 列表这类数据结构确实很好用，但遇到类、字符串仍然和 print 差别不大，因此这里有一个国人写的第三方库介绍给大家。</p><h2 id="beeprint"><a href="#beeprint" class="headerlink" title="beeprint"></a><strong>beeprint</strong></h2><p>除了和 pprint 一样支持 dict, list, tuple 等常规变量的格式化输出，还支持 object 变量打印、长文本自动剪切。</p><p>下面是作者 README 中和 pprint 的对比：</p><p><strong>pprint:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#39;entities&#39;: &#123;&#39;hashtags&#39;: \[\],</span><br><span class="line">              &#39;urls&#39;: \[&#123;&#39;display_url&#39;: &#39;tumblr.com&#x2F;xnr37hf0yz&#39;,</span><br><span class="line">                        &#39;expanded_url&#39;: &#39;http:&#x2F;&#x2F;tumblr.com&#x2F;xnr37hf0yz&#39;,</span><br><span class="line">                        &#39;indices&#39;: \[107, 126\],</span><br><span class="line">                        &#39;url&#39;: &#39;http:&#x2F;&#x2F;t.co&#x2F;cCIWIwg&#39;&#125;\],</span><br><span class="line">              &#39;user_mentions&#39;: \[\]&#125;&#125;</span><br></pre></td></tr></table></figure><p><strong>beeprint:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &#39;entities&#39;: &#123;</span><br><span class="line">    &#39;hashtags&#39;: \[\],</span><br><span class="line">    &#39;urls&#39;: \[</span><br><span class="line">      &#123;</span><br><span class="line">        &#39;display_url&#39;: &#39;tumblr.com&#x2F;xnr37hf0yz&#39;,</span><br><span class="line">        &#39;expanded_url&#39;: &#39;http:&#x2F;&#x2F;tumblr.com&#x2F;xnr37hf0yz&#39;,</span><br><span class="line">        &#39;indices&#39;: \[107, 126\],</span><br><span class="line">        &#39;url&#39;: &#39;http:&#x2F;&#x2F;t.co&#x2F;cCIWIwg&#39;,</span><br><span class="line">      &#125;,</span><br><span class="line">    \],</span><br><span class="line">    &#39;user_mentions&#39;: \[\],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>pprint:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &#39;definition.NormalClassNewStyle&#39;&gt;</span><br></pre></td></tr></table></figure><p><strong>beeprint:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class(NormalClassNewStyle):</span><br><span class="line">  dicts: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  lists: \[\],</span><br><span class="line">  static_props: 1,</span><br><span class="line">  tuple: (1, 2)</span><br></pre></td></tr></table></figure><p><strong>pprint:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;definition.NormalClassNewStyle object at 0x7f338e5a9dd0&gt;</span><br></pre></td></tr></table></figure><p><strong>beeprint:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">instance(NormalClassNewStyle):</span><br><span class="line">  dicts: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  lists: \[\],</span><br><span class="line">  say_hi: &#39;hello world&#39;,</span><br><span class="line">  static_props: 1,</span><br><span class="line">  tuple: (1, 2)</span><br></pre></td></tr></table></figure><p><strong>pprint:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\[\[&#39;\\nThe sky and the earth were at first one blurred entity like an egg. Pangu was born into it.\\n \\n\\tThe separation of the sky and the earth took eighteen thousand years-the yang which was light and pure rose to become the sky, \\tand the yin which was heavy and murky\\xef\\xbc\\x88\\xe6\\x9c\\xa6\\xe8\\x83\\xa7\\xe7\\x9a\\x84\\xef\\xbc\\x89 sank to form the earth. Between them was Pangu, who went through nine \\tchanges every day, his wisdom greater than that of the sky and his ability greater than that of the earth. Every day the sky rose ten feet higher, the earth became ten feet thicker, and Pangu grew ten feet taller.\\n \\nAnother eighteen thousand years passed, and there was an extremely high sky, an extremely thick earth, and an extremely tall Pangu. After Pangu died, his head turned into the Five Sacred Mountains (Mount Tai, Mount Heng, Mount Hua, Mount Heng, Mount Song), his eyes turned into the moon and the sun, his blood changed into water in river and sea, his hair into grass.\\n \\nIn all, the universe and Pangu combine in one.\\n&#39;,</span><br><span class="line">  &#39;\\n\\xe6\\x8d\\xae\\xe6\\xb0\\x91\\xe9\\x97\\xb4\\xe7\\xa5\\x9e\\xe8\\xaf\\x9d\\xe4\\xbc\\xa0\\xe8\\xaf\\xb4\\xe5\\x8f\\xa4\\xe6\\x97\\xb6\\xe7\\x9b\\x98\\xe5\\x8f\\xa4\\xe7\\x94\\x9f\\xe5\\x9c\\xa8\\xe9\\xbb\\x91\\xe6\\x9a\\x97\\xe5\\x9b\\xa2\\xe4\\xb8\\xad\\xef\\xbc\\x8c\\xe4\\xbb\\x96\\xe4\\xb8\\x8d\\xe8\\x83\\xbd\\xe5\\xbf\\x8d\\xe5\\x8f\\x97\\xe9\\xbb\\x91\\xe6\\x9a\\x97\\xef\\xbc\\x8c\\xe7\\x94\\xa8\\xe7\\xa5\\x9e\\xe6\\x96\\xa7\\xe5\\x8a\\x88\\xe5\\x90\\x91\\xe5\\x9b\\x9b\\xe6\\x96\\xb9\\xef\\xbc\\x8c\\xe9\\x80\\x90\\xe6\\xb8\\x90\\xe4\\xbd\\xbf\\xe5\\xa4\\xa9\\xe7\\xa9\\xba\\xe9\\xab\\x98\\xe8\\xbf\\x9c\\xef\\xbc\\x8c\\xe5\\xa4\\xa7\\xe5\\x9c\\xb0\\xe8\\xbe\\xbd\\xe9\\x98\\x94\\xe3\\x80\\x82\\n\\t\\xe4\\xbb\\x96\\xe4\\xb8\\xba\\xe4\\xb8\\x8d\\xe4\\xbd\\xbf\\xe5\\xa4\\xa9\\xe5\\x9c\\xb0\\xe4\\xbc\\x9a\\xe9\\x87\\x8d\\xe6\\x96\\xb0\\xe5\\x90\\x88\\xe5\\xb9\\xb6\\xef\\xbc\\x8c\\xe7\\xbb\\xa7\\xe7\\xbb\\xad\\xe6\\x96\\xbd\\xe5\\xb1\\x95\\xe6\\xb3\\x95\\xe6\\x9c\\xaf\\xe3\\x80\\x82\\xe6\\xaf\\x8f\\xe5\\xbd\\x93\\xe7\\x9b\\x98\\xe5\\x8f\\xa4\\xe7\\x9a\\x84\\xe8\\xba\\xab\\xe4\\xbd\\x93\\xe9\\x95\\xbf\\xe9\\xab\\x98\\xe4\\xb8\\x80\\xe5\\xb0\\xba\\xef\\xbc\\x8c\\xe5\\xa4\\xa9\\xe7\\xa9\\xba\\xe5\\xb0\\xb1\\xe9\\x9a\\x8f\\xe4\\xb9\\x8b\\xe5\\xa2\\x9e\\xe9\\xab\\x98\\xe4\\xb8\\x80\\xe5\\xb0\\xba\\xef\\xbc\\x8c\\n\\t\\xe7\\xbb\\x8f\\xe8\\xbf\\x871.8\\xe4\\xb8\\x87\\xe5\\xa4\\x9a\\xe5\\xb9\\xb4\\xe7\\x9a\\x84\\xe5\\x8a\\xaa\\xe5\\x8a\\x9b\\xef\\xbc\\x8c\\xe7\\x9b\\x98\\xe5\\x8f\\xa4\\xe5\\x8f\\x98\\xe6\\x88\\x90\\xe4\\xb8\\x80\\xe4\\xbd\\x8d\\xe9\\xa1\\xb6\\xe5\\xa4\\xa9\\xe7\\xab\\x8b\\xe5\\x9c\\xb0\\xe7\\x9a\\x84\\xe5\\xb7\\xa8\\xe4\\xba\\xba\\xef\\xbc\\x8c\\xe8\\x80\\x8c\\xe5\\xa4\\xa9\\xe7\\xa9\\xba\\xe4\\xb9\\x9f\\xe5\\x8d\\x87\\xe5\\xbe\\x97\\xe9\\xab\\x98\\xe4\\xb8\\x8d\\xe5\\x8f\\xaf\\xe5\\x8f\\x8a\\xef\\xbc\\x8c\\xe5\\xa4\\xa7\\xe5\\x9c\\xb0\\xe4\\xb9\\x9f\\xe5\\x8f\\x98\\xe5\\xbe\\x97\\xe5\\x8e\\x9a\\xe5\\xae\\x9e\\xe6\\x97\\xa0\\xe6\\xaf\\x94\\xe3\\x80\\x82\\xe7\\x9b\\x98\\xe5\\x8f\\xa4\\xe7\\x94\\x9f\\xe5\\x89\\x8d\\xe5\\xae\\x8c\\xe6\\x88\\x90\\xe5\\xbc\\x80\\xe5\\xa4\\xa9\\xe8\\xbe\\x9f\\xe5\\x9c\\xb0\\xe7\\x9a\\x84\\xe4\\xbc\\x9f\\xe5\\xa4\\xa7\\xe4\\xb8\\x9a\\xe7\\xbb\\xa9\\xef\\xbc\\x8c\\xe6\\xad\\xbb\\xe5\\x90\\x8e\\xe6\\xb0\\xb8\\xe8\\xbf\\x9c\\xe7\\x95\\x99\\xe7\\xbb\\x99\\xe5\\x90\\x8e\\xe4\\xba\\xba\\xe6\\x97\\xa0\\xe7\\xa9\\xb7\\xe6\\x97\\xa0\\xe5\\xb0\\xbd\\xe7\\x9a\\x84\\xe5\\xae\\x9d\\xe8\\x97\\x8f\\xef\\xbc\\x8c\\xe6\\x88\\x90\\xe4\\xb8\\xba\\xe4\\xb8\\xad\\xe5\\x8d\\x8e\\xe6\\xb0\\x91\\xe6\\x97\\x8f\\xe5\\xb4\\x87\\xe6\\x8b\\x9c\\xe7\\x9a\\x84\\xe8\\x8b\\xb1\\xe9\\x9b\\x84\\xe3\\x80\\x82\\n&#39;\]\]</span><br></pre></td></tr></table></figure><p><strong>beeprint:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">\[</span><br><span class="line">  \[</span><br><span class="line">    &#39;\\nThe sky and the earth were at first one blurred entity like an egg. Pangu</span><br><span class="line">     was born into it.\\n \\n\\tThe separation of the sky and the earth took</span><br><span class="line">     ...(12 hidden lines)&#39;,</span><br><span class="line">    &#39;\\n据民间神话传说古时盘古生在黑暗团中，他不能忍受黑暗，用神斧劈向四方，逐渐</span><br><span class="line">     使天空高远，大地辽阔。\\n\\t他为不使天地会重新合并，继续施展法术。每当盘古的</span><br><span class="line">     ...(3 hidden lines)&#39;,</span><br><span class="line">  \],</span><br><span class="line">\]</span><br></pre></td></tr></table></figure><p><strong><code>beeprint.pp</code></strong><em>(o, output=True, max_depth=5, indent=2, width=80, sort_keys=True, config=None, **kwargs):</em></p><p>参数和 pprint 类似，多出了 sort_keys可以打印字典时是否按 key 排序（ pprint 是默认排序，不可选），另外还有控制文本裁剪等行为的参数，可以从 <code>beeprint.Config</code> 里查看。</p><p>该库的 Github：<a href="https://github.com/panyanyany/beeprint" target="_blank" rel="noopener">https://github.com/panyanyany/beeprint</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 3.7.0 正式版发布，新特性翻译</title>
      <link href="/2018/06/28/Python%203.7.0%20%E6%AD%A3%E5%BC%8F%E7%89%88%E5%8F%91%E5%B8%83%EF%BC%8C%E6%96%B0%E7%89%B9%E6%80%A7%E7%BF%BB%E8%AF%91/"/>
      <url>/2018/06/28/Python%203.7.0%20%E6%AD%A3%E5%BC%8F%E7%89%88%E5%8F%91%E5%B8%83%EF%BC%8C%E6%96%B0%E7%89%B9%E6%80%A7%E7%BF%BB%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<blockquote><p>美国时间6月27日晚8点，Python 3.7.0 经过多轮测试，终于发布了正式版，增强了多处特性功能，同时 3.6 也更新到 3.6.6 稳定版本。</p></blockquote><h2 id="主要特性"><a href="#主要特性" class="headerlink" title="主要特性"></a>主要特性</h2><ul><li>PEP 539，新增 CPython 中用于线程本地存储的 C-API</li><li>PEP 545，Python 官方文档翻译版本，新增日文、法文、韩文</li><li>PEP 552，优化 pyc 文件</li><li>PEP 553，新增内置函数 breakpoint() ，该函数在调用时自动进入调试器</li><li>PEP 557，新增内置模块dataclasses，可大幅简化类实例属性的初始化定义</li><li>PEP 560，新增支持类型模块和泛型</li><li>PEP 562，支持在模块定义 getattr 和<strong>dir</strong></li><li>PEP 563，推迟对注释语句的分析从而优化 Python 的类型提示</li><li>PEP 564，time 内置函数支持纳秒</li><li>PEP 565，重新在 main 中默认显示 DeprecationWarning</li><li>PEP 567，新增 contextvars模块，可实现上下文变量解决变量线程安全</li><li>避免使用 ASCII 作为默认文本编码，强制 UTF-8 编码运行</li><li>字典对象的 keys 按插入顺序排列，现在是官方语言规范</li><li>多方面的显著性能优化</li></ul><h2 id="dataclasses模块-示例"><a href="#dataclasses模块-示例" class="headerlink" title="dataclasses模块 示例"></a>dataclasses模块 示例</h2><p>这个特性可能是 3.7.0 以后比较常用的了，是从其他语言借鉴过来的，这里简单演示下用法。</p><p>假如我们要封装一个类对象，在之前我们的代码可能要这么写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Article</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, _id, author_id, title, text, tags=None, </span></span></span><br><span class="line"><span class="function"><span class="params">                 created=datetime.now<span class="params">()</span>, edited=datetime.now<span class="params">()</span>)</span>:</span></span><br><span class="line">    self._id = _id</span><br><span class="line">    self.author_id = author_id</span><br><span class="line">    self.title = title</span><br><span class="line">    self.text = text</span><br><span class="line">    self.tags = list() <span class="keyword">if</span> tags <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> tags</span><br><span class="line">    self.created = created</span><br><span class="line">    self.edited = edited</span><br><span class="line">    <span class="keyword">if</span> type(self.created) <span class="keyword">is</span> str:</span><br><span class="line">       self.created = dateutil.parser.parse(self.created)</span><br><span class="line">    <span class="keyword">if</span> type(self.edited) <span class="keyword">is</span> str:</span><br><span class="line">       self.edited = dateutil.parser.parse(self.edited)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(other, self.__class__):</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br><span class="line">        <span class="keyword">return</span> (self._id, self.author_id) == (other._id, other.author_id)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(other, self.__class__):</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br><span class="line">        <span class="keyword">return</span> (self._id, self.author_id) &lt; (other._id, other.author_id)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&#123;&#125;(id=&#123;&#125;, author_id=&#123;&#125;, title=&#123;&#125;)'</span>.format(</span><br><span class="line">               self.__class__.__name__, self._id, self.author_id, self.title)</span><br></pre></td></tr></table></figure><p>大量的初始化属性要定义默认值，可能还需要重写一堆魔法方法，来实现类实例之间的排序 去重 等功能。</p><p>如果使用 <code>dataclasses</code> 进行改造，可以写成这个样子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@dataclass(order=True)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Article</span><span class="params">(object)</span>:</span></span><br><span class="line">    _id: int</span><br><span class="line">    author_id: int</span><br><span class="line">    title: str = field(compare=<span class="literal">False</span>)</span><br><span class="line">    text: str = field(repr=<span class="literal">False</span>, compare=<span class="literal">False</span>)</span><br><span class="line">    tags: List[str] = field(default=list(), repr=<span class="literal">False</span>, compare=<span class="literal">False</span>)</span><br><span class="line">    created: datetime = field(default=datetime.now(), repr=<span class="literal">False</span>, compare=<span class="literal">False</span>)</span><br><span class="line">    edited: datetime = field(default=datetime.now(), repr=<span class="literal">False</span>, compare=<span class="literal">False</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__post_init__</span><span class="params">(self)</span>:</span></span><br><span class="line">       <span class="keyword">if</span> type(self.created) <span class="keyword">is</span> str:</span><br><span class="line">           self.created = dateutil.parser.parse(self.created)</span><br><span class="line">       <span class="keyword">if</span> type(self.edited) <span class="keyword">is</span> str:</span><br><span class="line">           self.edited = dateutil.parser.parse(self.edited)</span><br></pre></td></tr></table></figure><p>可见这种语法使代码更加简练清晰，也更符合面向对象思想的语法方式，用过 SQLAlchemy 的同学肯定觉得很像 ORM 写法。</p><p>上述示例只是最基础的展示，更丰富的用法可以查看- PEP 557文档。</p><p>3.7 版本下载地址：<br><a href="https://www.python.org/downloads/" target="_blank" rel="noopener">https://www.python.org/downloads/</a></p><p>更多特性：<br><a href="https://docs.python.org/3.7/whatsnew/3.7.html" target="_blank" rel="noopener">https://docs.python.org/3.7/whatsnew/3.7.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019年最新 Python 模拟登录知乎 支持验证码</title>
      <link href="/2018/03/06/2019%E5%B9%B4%E6%9C%80%E6%96%B0%20Python%20%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95%E7%9F%A5%E4%B9%8E%20%E6%94%AF%E6%8C%81%E9%AA%8C%E8%AF%81%E7%A0%81/"/>
      <url>/2018/03/06/2019%E5%B9%B4%E6%9C%80%E6%96%B0%20Python%20%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95%E7%9F%A5%E4%B9%8E%20%E6%94%AF%E6%8C%81%E9%AA%8C%E8%AF%81%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<blockquote><p>知乎的登录页面已经改版多次，加强了身份验证，网络上大部分模拟登录均已失效，所以我重写了一份完整的，并实现了提交验证码 (包括中文验证码)，本文我对分析过程和代码进行步骤分解，完整的代码请见末尾 Github 仓库，不过还是建议看一遍正文，因为代码早晚会失效，解析思路才是永恒。</p></blockquote><h2 id="分析-POST-请求"><a href="#分析-POST-请求" class="headerlink" title="分析 POST 请求"></a>分析 POST 请求</h2><p>首先打开控制台正常登录一次，可以很快找到登录的 API 接口，这个就是模拟登录 POST 的链接。</p><p><img src="https://static.zkqiang.cn/images/20190725215222.jpeg-slim" alt=""></p><p>我们的最终目标是构建 POST 请求所需的 Headers 和 Form-Data 这两个对象即可。</p><h2 id="构建-Headers"><a href="#构建-Headers" class="headerlink" title="构建 Headers"></a>构建 Headers</h2><p>继续看<code>Requests Headers</code>信息，和登录页面的 GET 请求对比发现，这个 POST 的头部多了三个身份验证字段，经测试<code>x-xsrftoken</code>是必需的。<br><code>x-xsrftoken</code>则是防 Xsrf 跨站的 Token 认证，访问首页时从<code>Response Headers</code>的<code>Set-Cookie</code>字段中可以找到。</p><p><img src="https://static.zkqiang.cn/images/20190725215226.jpeg-slim" alt=""></p><h2 id="构建-Form-Data"><a href="#构建-Form-Data" class="headerlink" title="构建 Form-Data"></a>构建 Form-Data</h2><p>Form部分目前已经是加密的，无法再直观看到，可以通过在 JS 里打断点的方式（具体这里不再赘述，如不会打断点请自行搜索）。  </p><p><img src="https://static.zkqiang.cn/images/20190725215223.jpeg-slim" alt=""></p><p><img src="https://static.zkqiang.cn/images/20190725215225.jpeg-slim" alt=""></p><p>然后我们逐个构建上图这些参数：<br><code>timestamp</code> 时间戳，这个很好解决，区别是这里是13位整数，Python 生成的整数部分只有10位，需要额外乘以1000</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timestamp = str(int(time.time()*<span class="number">1000</span>))</span><br></pre></td></tr></table></figure><p><code>signature</code> 通过 Ctrl+Shift+F 搜索找到是在一个 JS 里生成的，是通过 Hmac 算法对几个固定值和时间戳进行加密，那么只需要在 Python 里也模拟一次这个加密即可。</p><p><img src="https://static.zkqiang.cn/images/20190725215224.jpeg-slim" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_get_signature</span><span class="params">(self, timestamp)</span>:</span></span><br><span class="line">    ha = hmac.new(<span class="string">b'd1b964811afb40118a12068ff74a12f4'</span>, digestmod=hashlib.sha1)</span><br><span class="line">    grant_type = self.login_data[<span class="string">'grant_type'</span>]</span><br><span class="line">    client_id = self.login_data[<span class="string">'client_id'</span>]</span><br><span class="line">    source = self.login_data[<span class="string">'source'</span>]</span><br><span class="line">    ha.update(bytes((grant_type + client_id + source + timestamp), <span class="string">'utf-8'</span>))</span><br><span class="line">    <span class="keyword">return</span> ha.hexdigest()</span><br></pre></td></tr></table></figure><p><code>captcha</code> 验证码，是通过 GET 请求单独的 API 接口返回是否需要验证码（无论是否需要，都要请求一次），如果是 True 则需要再次 PUT 请求获取图片的 base64 编码。</p><p><img src="https://static.zkqiang.cn/images/20190725215221.jpeg-slim" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">resp = self.session.get(api, headers=headers)</span><br><span class="line">show_captcha = re.search(<span class="string">r'true'</span>, resp.text)</span><br><span class="line"><span class="keyword">if</span> show_captcha:</span><br><span class="line">    put_resp = self.session.put(api, headers=headers)</span><br><span class="line">    json_data = json.loads(put_resp.text)</span><br><span class="line">    img_base64 = json_data[<span class="string">'img_base64'</span>].replace(<span class="string">r'\n'</span>, <span class="string">''</span>)</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'./captcha.jpg'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(base64.b64decode(img_base64))</span><br><span class="line">        img = Image.open(<span class="string">'./captcha.jpg'</span>)</span><br></pre></td></tr></table></figure><p>实际上有两个 API，一个是识别倒立汉字，一个是常见的英文验证码，任选其一即可，代码中我将两个都实现了，汉字是通过 plt 点击坐标，然后转为 JSON 格式。（另外，这里其实可以通过重新请求登录页面避开验证码，如果你需要自动登录的话可以改造试试）<br>最后还有一点要注意，如果有验证码，需要将验证码的参数先 POST 到验证码 API，再随其他参数一起 POST 到登录 API。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> lang == <span class="string">'cn'</span>:</span><br><span class="line">    <span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">    plt.imshow(img)</span><br><span class="line">    print(<span class="string">'点击所有倒立的汉字，按回车提交'</span>)</span><br><span class="line">    points = plt.ginput(<span class="number">7</span>)</span><br><span class="line">    capt = json.dumps(&#123;<span class="string">'img_size'</span>: [<span class="number">200</span>, <span class="number">44</span>],</span><br><span class="line">                       <span class="string">'input_points'</span>: [[i[<span class="number">0</span>]/<span class="number">2</span>, i[<span class="number">1</span>]/<span class="number">2</span>] <span class="keyword">for</span> i <span class="keyword">in</span> points]&#125;)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    img.show()</span><br><span class="line">    capt = input(<span class="string">'请输入图片里的验证码：'</span>)</span><br><span class="line">    <span class="comment"># 这里必须先把参数 POST 验证码接口</span></span><br><span class="line">    self.session.post(api, data=&#123;<span class="string">'input_text'</span>: capt&#125;, headers=headers)</span><br><span class="line">    <span class="keyword">return</span> capt</span><br></pre></td></tr></table></figure><p>然后把 username 和 password 两个值更新进去，其他字段都保持固定值即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">self.login_data.update(&#123;</span><br><span class="line">    <span class="string">'username'</span>: self.username,</span><br><span class="line">    <span class="string">'password'</span>: self.password,</span><br><span class="line">    <span class="string">'lang'</span>: captcha_lang</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">timestamp = int(time.time()*<span class="number">1000</span>)</span><br><span class="line">self.login_data.update(&#123;</span><br><span class="line">    <span class="string">'captcha'</span>: self._get_captcha(self.login_data[<span class="string">'lang'</span>]),</span><br><span class="line">    <span class="string">'timestamp'</span>: timestamp,</span><br><span class="line">    <span class="string">'signature'</span>: self._get_signature(timestamp)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="加密-Form-Data"><a href="#加密-Form-Data" class="headerlink" title="加密 Form-Data"></a>加密 Form-Data</h2><p>但是现在知乎必须先将 Form-Data 加密才能进行 POST 传递，所以我们还要解决加密问题，可由于我们看到的 JS 是混淆后的代码，想窥视其中的加密实现方式是一件很费精力的事情。<br>所以这里我采用了 sergiojune 这位知友通过 <code>pyexecjs</code> 调用 JS 进行加密的方式，只需要把混淆代码完整复制过来，稍作修改即可。<br>具体可看他的原文：<a href="https://zhuanlan.zhihu.com/p/57375111" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/57375111</a>  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'./encrypt.js'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    js = execjs.compile(f.read())</span><br><span class="line">    <span class="keyword">return</span> js.call(<span class="string">'Q'</span>, urlencode(form_data))</span><br></pre></td></tr></table></figure><p>这里也感谢他分享了一些坑，不然确实不好解决。</p><h2 id="保存-Cookies"><a href="#保存-Cookies" class="headerlink" title="保存 Cookies"></a>保存 Cookies</h2><p>最后实现一个检查登录状态的方法，如果访问登录页面出现跳转，说明已经登录成功，这时将 Cookies 保存起来（这里 session.cookies 初始化为 LWPCookieJar 对象，所以有 save 方法），这样下次登录可以直接读取 Cookies 文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_login</span><span class="params">(self)</span>:</span></span><br><span class="line">    resp = self.session.get(self.login_url, allow_redirects=<span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">if</span> resp.status_code == <span class="number">302</span>:</span><br><span class="line">        self.session.cookies.save()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>关注微信公众号：<strong>面向人生编程</strong> (可扫本页底部二维码)，回复”<strong>知乎</strong>“获得代码</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何理解“面向对象”编程思想</title>
      <link href="/2018/03/03/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E2%80%9C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E2%80%9D%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
      <url>/2018/03/03/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E2%80%9C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E2%80%9D%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<p>知乎问题：<a href="https://www.zhihu.com/question/313687376/answer/612636893" target="_blank" rel="noopener">怎么理解面向对象？</a></p><p>以下是我的回答：</p><p>理解面向对象，首先理解要它的基础概念：</p><p>面向对象 ( Object Oriented ) 是将现实问题构建关系，然后抽象成 <strong>类 ( class )</strong>，给类定义属性和方法后，再将类实例化成 <strong>实例 ( instance )</strong> ，通过访问实例的属性和调用方法来进行使用。</p><p>在不同的语言中，对象的定义范围不同。在 Python 中“类”和“类的实例”都称为 <strong>对象 ( Object )</strong>，因为 Python 的类是更顶级的 type 实例化后的对象，也就是常说的“Python 里万物皆对象”；而在 Java 等静态语言中，一般把类的实例称为对象。</p><p>理解了理论知识后，接着通过例子，再理解面向对象的三大特征：封装、继承、多态。</p><p>下边我们把“女娲造人”这个神话故事，用 Python 的面向对象代码来叙述一遍：</p><p>假设我们是女娲（程序设计者），我们突然有个想法，想造一群和自己差不多的小人，小人需要有男女两种性别，外观和行为也有一些差异。那首先我们分析出，不管什么性别，都应该有四肢，所以我们先仿照自己的构造，在脑海中构思泥人的样子（抽象成基类），然后先赋予泥人一些共有的行为（定义类的实例方法）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="comment"># 有个名字，有两只手，两条腿</span></span><br><span class="line">        self._name = name</span><br><span class="line">        self.hands = <span class="number">2</span></span><br><span class="line">        self.legs = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">introduce_self</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 介绍自己</span></span><br><span class="line">        print(<span class="string">'我是%s'</span> % self._name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 工作，但还没有定义具体的行为</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br></pre></td></tr></table></figure><p>然后我们先捏3个泥人（<strong>实例化</strong>对象），并给他们取了不同的名字（初始化实例属性）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = Human(<span class="string">'大强子'</span>)</span><br><span class="line">&gt;&gt;&gt; b = Human(<span class="string">'二狗子'</span>)</span><br><span class="line">&gt;&gt;&gt; c = Human(<span class="string">'三愣子'</span>)</span><br></pre></td></tr></table></figure><p>我们让其中一个人介绍自己（调用实例方法）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a.introduce_self()</span><br><span class="line">我是大强子</span><br></pre></td></tr></table></figure><p>这里解释一下 <code>Human</code> 的代码，虽然设定了每个人都要工作，但如何工作需要到具体到不同类型的人，所以在基类里我们并没有定义 <code>work</code> 方法的内容，如果强行调用会抛出异常。</p><p>还有一点，上面定义属性时，我们把 <code>self._name</code> 前边加了下划线，是因为 Python 里用下划线来约定这是一个受保护变量（对应 Java 中的 <code>protected</code> ），我们不希望外界能直接访问 <code>name</code> 这个属性，必须要通过对象调用 <code>introduce_self()</code> 这个行为介绍了自己，别人才能知道他叫什么名字，这个过程就称之为<strong>封装</strong>。</p><p>然后我们继续完成想法，需要给泥人增加两种性别，并且异性之间能结婚，我们开始在刚才泥人模型的基础上（<strong>继承</strong>于基类），构思出两种性别的泥人的区别（设置不同的属性），然后让他们都可以工作，但工作的内容不一样（调用相同的方法出现不同结果，是<strong>多态</strong>性），并决定让男人可以娶女人（将这个行为定义为男人的方法）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Female</span><span class="params">(Human)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="comment"># 调用父类的初始化方法，依然有名字、两只手、两条腿</span></span><br><span class="line">        super().__init__(name)</span><br><span class="line">        <span class="comment"># 头发和力量进行随机取值</span></span><br><span class="line">        self.hair = random.randint(<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">        self.power = random.randint(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">        <span class="comment"># 是否已婚</span></span><br><span class="line">        self.married = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'%s采摘了一些果子'</span> % self.name)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Male</span><span class="params">(Human)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        super().__init__(name)</span><br><span class="line">        self.hair = random.randint(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">        self.power = random.randint(<span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line">        self.married = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'%s出去打猎了一天'</span> % self.name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">marry</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="comment"># 判断自己或对方是否已结婚，否则抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> self.married <span class="keyword">is</span> <span class="literal">True</span> <span class="keyword">or</span> other.married <span class="keyword">is</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'法律不支持多次结婚'</span>)</span><br><span class="line">        <span class="comment"># 判断对方是否是女性，否则抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(other, Female):</span><br><span class="line">            self.married = <span class="literal">True</span></span><br><span class="line">            other.married = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">'法律不支持同性结婚'</span>)</span><br></pre></td></tr></table></figure><p>然后我们就可以让小人活动起来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = Male(<span class="string">'大强子'</span>)</span><br><span class="line">&gt;&gt;&gt; b = Male(<span class="string">'二狗子'</span>)</span><br><span class="line">&gt;&gt;&gt; c = Female(<span class="string">'翠花'</span>)</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">for</span> h <span class="keyword">in</span> [a, b, c]:</span><br><span class="line">...     <span class="comment"># 调用父类的方法</span></span><br><span class="line">...     h.introduce_self()</span><br><span class="line">我是大强子</span><br><span class="line">我是二狗子</span><br><span class="line">我是翠花</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">for</span> h <span class="keyword">in</span> [a, b, c]:</span><br><span class="line">...     <span class="comment"># 多态性使相同的方法产生不同的结果</span></span><br><span class="line">...     h.work()</span><br><span class="line">大强子出去打猎了一天</span><br><span class="line">二狗子出去打猎了一天</span><br><span class="line">翠花采摘了一些果子</span><br><span class="line">&gt;&gt;&gt; a.marry(c)</span><br><span class="line">&gt;&gt;&gt; a.married</span><br><span class="line"><span class="literal">True</span></span><br><span class="line">&gt;&gt;&gt; c.married</span><br><span class="line"><span class="literal">True</span></span><br><span class="line">&gt;&gt;&gt; b.marry(c)</span><br><span class="line">ValueError: 法律不支持多次结婚</span><br><span class="line">&gt;&gt;&gt; b.marry(a)</span><br><span class="line">TypeError: 法律不支持同性结婚</span><br></pre></td></tr></table></figure><p>设计到此结束，我们来复盘一下整个过程。</p><p>我们先是把人的共有特征抽象成 <code>Human</code> 基类，这个基类并不用于实例化，而是用于让 <code>Female</code> 和 <code>Male</code> 继承它，并实现不同的行为。这样我们就避免把一些共有的行为重复在多个类里定义，如果我们后续想对人类的行为进行变动，也只需要修改 <code>Human</code>，继承 <code>Human</code> 的子类会自动获得新行为，这是 <strong>继承</strong>带来的好处。</p><p>我们把 <code>name</code> 设计为受保护变量，外界无法直接访问这个属性，让每个人的隐私得到了保障（一些不必要的行为变得可控），这是 <strong>封装</strong> 带来的好处。</p><p>同时我们在 <code>Human</code> 中预留了 <code>work</code> 方法，并在 <code>Female</code> 和 <code>Male</code> 都实现了不同的效果，然后我们知道人人都有 <code>work</code> 方法，因此可以像 <code>introduce_self</code> 一样，用循环批量调用 <code>work</code> 方法，这是 <strong>多态</strong> 带来的好处。</p><p>看到这里你应该有些理解：面向对象是将客观事物和一些关系，抽象成具体的模型（类），并为其设计属性和方法，即 <strong>对象 = 属性（特征）+ 方法（行为）</strong>。</p><p>如果是拥有复杂关系的需求，我们就应该尽可能将互相有关联的行为抽象成类，比如每一个网页，网页中每一个组件 等等。实际上面向对象帮助我们在几万行代码的大型项目中，仍然可以游刃有余，正因为如此，才能发展为目前应用最为广泛的编程思想。</p><p>但也并不是说任何时候都要“面向对象”，过度的封装和抽象，也会造成代码可读性的下降，以及运行效率的下降，因此我们应该<strong>在能将事物抽象化的需求中使用面向对象</strong>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>适合 Python 初学者的一些技巧和坑</title>
      <link href="/2018/02/26/%E9%80%82%E5%90%88%20Python%20%E5%88%9D%E5%AD%A6%E8%80%85%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8A%80%E5%B7%A7%E5%92%8C%E5%9D%91/"/>
      <url>/2018/02/26/%E9%80%82%E5%90%88%20Python%20%E5%88%9D%E5%AD%A6%E8%80%85%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8A%80%E5%B7%A7%E5%92%8C%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前几天董大 <a href="https://www.zhihu.com/people/6d23d8e16eb481e548032719bb5898a4" target="_blank" rel="noopener">@董伟明</a> 的爱派森上线了，还发了一套 PPT 和视频，PPT 共有75页干货，讲了很多进阶的用法，也包括很多坑，非常适合刚入门的同学，免得再踩到。</p><p><a href="https://zhuanlan.zhihu.com/p/33517855?utm_medium=social&utm_source=qq" target="_blank" rel="noopener">PPT和视频的传送门</a></p><p>这里我提取部分非常规的，也就是大部分教程里没有的，加入自己的理解，同时语法改为 Python 3，也争取延伸一些，就当是做笔记了。</p><h2 id="设置全局变量"><a href="#设置全局变量" class="headerlink" title="设置全局变量"></a>设置全局变量</h2><p>有时候设置全局变量的需求并不是直接赋值，而是想从某个数据结构里引用生成，可以用下面这两种方法，推荐第二种，<code>golbals()</code> 支持字典用法很方便。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>:<span class="number">2</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 粗暴的写法</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> k, v <span class="keyword">in</span> d.items():</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">exec</span> <span class="string">"&#123;&#125;=&#123;&#125;"</span>.format(k, v)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 文艺的写法</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>globals().update(d)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'a'</span>, <span class="string">'b'</span></span><br><span class="line">(<span class="string">'a'</span>, <span class="string">'b'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>globals()[<span class="string">'a'</span>] = <span class="string">'b'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="string">'b'</span></span><br></pre></td></tr></table></figure><h2 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h2><p>用 <code>format</code> 方法可以支持很多种格式，这里就不多说了，可以看官方文档。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">"&#123;key&#125;=&#123;value&#125;"</span>.format(key=<span class="string">"a"</span>, value=<span class="number">10</span>) <span class="comment"># 使⽤命名参数</span></span><br><span class="line"><span class="string">'a=10'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">"[&#123;0:&lt;10&#125;], [&#123;0:^10&#125;], [&#123;0:*&gt;10&#125;]"</span>.format(<span class="string">"a"</span>) <span class="comment"># 左中右对⻬</span></span><br><span class="line"><span class="string">'[a         ], [    a     ], [*********a]'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">"&#123;0.platform&#125;"</span>.format(sys) <span class="comment"># 成员</span></span><br><span class="line"><span class="string">'darwin'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">"&#123;0[a]&#125;"</span>.format(dict(a=<span class="number">10</span>, b=<span class="number">20</span>)) <span class="comment"># 字典</span></span><br><span class="line"><span class="string">'10'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">"&#123;0[5]&#125;"</span>.format(range(<span class="number">10</span>)) <span class="comment"># 列表</span></span><br><span class="line"><span class="string">'5'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">"&#123;0!r:20&#125;"</span>.format(<span class="string">"Hello"</span>)</span><br><span class="line"><span class="string">"'Hello'             "</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">"&#123;0!s:20&#125;"</span>.format(<span class="string">"Hello"</span>)</span><br><span class="line"><span class="string">'Hello               '</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">"Today is: &#123;0:%a %b %d %H:%M:%S %Y&#125;"</span>.format(datetime.now())</span><br><span class="line"><span class="string">'Today is: Mon Mar 31 23:59:34 2014'</span></span><br></pre></td></tr></table></figure><h2 id="列表去重"><a href="#列表去重" class="headerlink" title="列表去重"></a>列表去重</h2><p>这里讲了两种方法，正常情况下 <code>set</code> 是更好的选择；</p><p>（注：这里董大视频讲解有误，方法一单位是1.1微妙，是慢于956纳秒，我也自己测试了，确实两种情况都不如 <code>set</code>）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(&#123;&#125;.fromkeys(l).keys())    <span class="comment"># 利用构建字典键去重</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="comment"># 列表去重(1)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(set(l))    <span class="comment"># 常见set函数去重</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">In [<span class="number">2</span>]: %timeit list(set(l))</span><br><span class="line"><span class="number">1000000</span> loops, best of <span class="number">3</span>: <span class="number">956</span> ns per loop</span><br><span class="line">In [<span class="number">3</span>]: %timeit list(&#123;&#125;.fromkeys(l).keys())</span><br><span class="line"><span class="number">1000000</span> loops, best of <span class="number">3</span>: <span class="number">1.1</span> µs per loop</span><br><span class="line">In [<span class="number">4</span>]: l = [random.randint(<span class="number">1</span>, <span class="number">50</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10000</span>)]</span><br><span class="line">In [<span class="number">5</span>]: %timeit list(set(l))</span><br><span class="line"><span class="number">1000</span> loops, best of <span class="number">3</span>: <span class="number">271</span> µs per loop</span><br><span class="line">In [<span class="number">6</span>]: %timeit &#123;&#125;.fromkeys(l).keys()</span><br><span class="line"><span class="number">1000</span> loops, best of <span class="number">3</span>: <span class="number">310</span> µs per loop</span><br></pre></td></tr></table></figure><h2 id="操作字典"><a href="#操作字典" class="headerlink" title="操作字典"></a>操作字典</h2><p>字典是 Python 很常用的数据结构，各种函数和方法要掌握。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict(([<span class="string">"a"</span>, <span class="number">1</span>], [<span class="string">"b"</span>, <span class="number">2</span>])) <span class="comment"># ⽤两个序列类型构造字典</span></span><br><span class="line">&#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict(zip(<span class="string">"ab"</span>, range(<span class="number">2</span>)))</span><br><span class="line">&#123;<span class="string">'a'</span>: <span class="number">0</span>, <span class="string">'b'</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict(map(<span class="literal">None</span>, <span class="string">"abc"</span>, range(<span class="number">2</span>)))</span><br><span class="line">&#123;<span class="string">'a'</span>: <span class="number">0</span>, <span class="string">'c'</span>: <span class="literal">None</span>, <span class="string">'b'</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict.fromkeys(<span class="string">"abc"</span>, <span class="number">1</span>) <span class="comment"># ⽤序列做 key,并提供默认 value</span></span><br><span class="line">&#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'c'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;k:v <span class="keyword">for</span> k, v <span class="keyword">in</span> zip(<span class="string">"abc"</span>, range(<span class="number">3</span>))&#125; <span class="comment"># 字典解析</span></span><br><span class="line">&#123;<span class="string">'a'</span>: <span class="number">0</span>, <span class="string">'c'</span>: <span class="number">2</span>, <span class="string">'b'</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">"a"</span>:<span class="number">1</span>, <span class="string">"b"</span>:<span class="number">2</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.setdefault(<span class="string">"a"</span>, <span class="number">100</span>) <span class="comment"># key 存在,直接返回 value 1 </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.setdefault(<span class="string">"c"</span>, <span class="number">200</span>) <span class="comment"># key 不存在,先设置,后返回 200 </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'c'</span>: <span class="number">200</span>, <span class="string">'b'</span>: <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="对字典进行逻辑操作"><a href="#对字典进行逻辑操作" class="headerlink" title="对字典进行逻辑操作"></a>对字典进行逻辑操作</h2><p>只能先转成键值对列表再进行操作，然后转回去；</p><p>(注：这里原文是 Python 2 中 <code>viewitems</code> 方法，已经被 <code>items</code> 替代)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d1 = dict(a = <span class="number">1</span>, b = <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d2 = dict(b = <span class="number">2</span>, c = <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d1 &amp; d2    <span class="comment"># 字典不⽀支持该操作</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: unsupported operand type(s) <span class="keyword">for</span> &amp;: <span class="string">'dict'</span> <span class="keyword">and</span> <span class="string">'dict'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = d1.items()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v2 = d2.items()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict(v1 &amp; v2)     <span class="comment"># 交集</span></span><br><span class="line">&#123;<span class="string">'b'</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict(v1 | v2)     <span class="comment"># 并集</span></span><br><span class="line">&#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'c'</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict(v1 - v2)     <span class="comment">#差集(仅v1有,v2没有的)</span></span><br><span class="line">&#123;<span class="string">'a'</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict(v1 ^ v2)    <span class="comment"># 对称差集 (不会同时出现在 v1 和 v2 中)</span></span><br><span class="line">&#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'c'</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="string">'a'</span>, <span class="number">1</span>) <span class="keyword">in</span> v1 <span class="comment">#判断</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><h2 id="vars"><a href="#vars" class="headerlink" title="vars"></a>vars</h2><p><code>vars()</code> 的作用是返回对象的属性和属性值的字典对象，如果没有参数，就打印当前调用位置的属性和属性值，类似 <code>locals()</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>vars() <span class="keyword">is</span> locals()</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>vars(sys) <span class="keyword">is</span> sys.__dict__    <span class="comment"># 可用于找类属性</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><h2 id="实现上下文管理类"><a href="#实现上下文管理类" class="headerlink" title="实现上下文管理类"></a>实现上下文管理类</h2><p>可以用来自动关闭 DB 连接</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pymongo</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Operation</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, database,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="meta">... </span>                 host=<span class="string">'localhost'</span>, port=<span class="number">27017</span>)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self._db = pymongo.MongoClient(</span><br><span class="line"><span class="meta">... </span>                      host, port)[database]</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> self._db</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_type, exc_val, exc_tb)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self._db.connection.disconnect()</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> Operation(database=<span class="string">'test'</span>) <span class="keyword">as</span> db:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> db.test.find_one()</span><br></pre></td></tr></table></figure><h2 id="contextlib"><a href="#contextlib" class="headerlink" title="contextlib"></a>contextlib</h2><p>这个模块主要包含一个装饰器 <code>contextmanager</code> ，作用是可以省去像上面那样改写魔术魔法，也能实现同样的类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>@contextlib.contextmanager</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">operation</span><span class="params">(database, host=<span class="string">'localhost'</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">                  port=<span class="number">27017</span>)</span>:</span></span><br><span class="line"><span class="meta">... </span>    db = pymongo.MongoClient(host, port)[database]</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> db</span><br><span class="line"><span class="meta">... </span>    db.connection.disconnect()</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pymongo</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> operation(<span class="string">'test'</span>) <span class="keyword">as</span> db:</span><br><span class="line"><span class="meta">... </span>    print(db.test.find_one())</span><br></pre></td></tr></table></figure><h2 id="包的构建"><a href="#包的构建" class="headerlink" title="包的构建"></a>包的构建</h2><p>如果包里有一些模块不想被 <code>import *</code> 这样引用，可以用 <code>__all__</code> 把允许被引用的放进去；</p><p><code>__all__ = [&quot;add&quot;, &quot;x&quot;]</code></p><p>某些时候,包内的文件太多,需要分类存放到多个目录中,但⼜不想拆分成新的包或子包。这么做是允许的, 只要在 <code>__init__.py</code> 中⽤ <code>__path__</code> 指定所有子目录的全路径即可 (子目录可放在包外)，下面这段代码可以自动指定子目录。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> os.path <span class="keyword">import</span> abspath, join</span><br><span class="line">subdirs = <span class="keyword">lambda</span> *dirs: [abspath(</span><br><span class="line">    join(__path__[<span class="number">0</span>], sub)) <span class="keyword">for</span> sub <span class="keyword">in</span> dirs]</span><br><span class="line">__path__ = subdirs(<span class="string">"a"</span>, <span class="string">"b"</span>)</span><br></pre></td></tr></table></figure><h2 id="slots"><a href="#slots" class="headerlink" title="slots"></a><strong>slots</strong></h2><p>限制给类实例绑定属性，大量属性时减少内存占用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">... </span>    __slots__ = (<span class="string">"name"</span>, <span class="string">"age"</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.name = name</span><br><span class="line"><span class="meta">... </span>        self.age = age</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>u = User(<span class="string">"Dong"</span>, <span class="number">28</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hasattr(u, <span class="string">"__dict__"</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>u.title = <span class="string">"xxx"</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: <span class="string">'User'</span> object has no attribute <span class="string">'title'</span></span><br></pre></td></tr></table></figure><h2 id="cached-property"><a href="#cached-property" class="headerlink" title="@cached_property"></a>@cached_property</h2><p>主要实现的功能是，被装饰的类实例方法在第一次调用后，会把值缓存下来，下次再调用会直接从 <code>__dict__</code> 取结果，避免了多次计算；你可以参考下面的代码实现这个装饰器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">cached_property</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="comment"># from werkzeug.utils import cached_property</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func, name=None, doc=None)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.__name__ = name <span class="keyword">or</span> func.__name__</span><br><span class="line"><span class="meta">... </span>        self.__module__ = func.__module__</span><br><span class="line"><span class="meta">... </span>        self.__doc__ = doc <span class="keyword">or</span> func.__doc__</span><br><span class="line"><span class="meta">... </span>        self.func = func</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, obj, type=None)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> obj <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">return</span> self</span><br><span class="line"><span class="meta">... </span>        value = obj.__dict__.get(self.__name__, _missing)</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> value <span class="keyword">is</span> _missing:</span><br><span class="line"><span class="meta">... </span>            value = self.func(obj)</span><br><span class="line"><span class="meta">... </span>            obj.__dict__[self.__name__] = value</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure><h2 id="元类里提前定义类方法"><a href="#元类里提前定义类方法" class="headerlink" title="元类里提前定义类方法"></a>元类里提前定义类方法</h2><p>这样可以像定义基类一样，提前给类定义一些方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">HelloMeta</span><span class="params">(type)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, name, bases, attrs)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(cls, func)</span>:</span></span><br><span class="line"><span class="meta">... </span>            cls.func = func</span><br><span class="line"><span class="meta">... </span>        <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(cls)</span>:</span></span><br><span class="line"><span class="meta">... </span>            <span class="keyword">print</span> <span class="string">'hello world'</span></span><br><span class="line"><span class="meta">... </span>        t = type.__new__(cls, name, bases, attrs)</span><br><span class="line"><span class="meta">... </span>        t.__init__ = __init__</span><br><span class="line"><span class="meta">... </span>        t.hello = hello</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> t     <span class="comment"># 最后要返回创建的类</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Hello</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">... </span>    __metaclass__ = HelloMeta</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>h = Hello(<span class="keyword">lambda</span> x: x+<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>h.hello()</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><h2 id="开发陷阱-一-：可变的默认参数"><a href="#开发陷阱-一-：可变的默认参数" class="headerlink" title="开发陷阱(一)：可变的默认参数"></a>开发陷阱(一)：可变的默认参数</h2><p>把临时变量作为默认参数里确实是不错的办法，但要警惕默认参数必须指向一个不可变类型，否则会踩到下面的坑</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">append_to</span><span class="params">(element, to=[])</span>:</span></span><br><span class="line"><span class="meta">... </span>    to.append(element)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> to</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_list = append_to(<span class="number">12</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_list</span><br><span class="line">[<span class="number">12</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_other_list = append_to(<span class="number">42</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_other_list</span><br><span class="line">[<span class="number">12</span>, <span class="number">42</span>]    <span class="comment"># 由于[]是可变类型，上次调用的元素还在里面</span></span><br><span class="line"><span class="comment"># 正确的做法是如下</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">append_to</span><span class="params">(element, to=None)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> to <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line"><span class="meta">... </span>        to = []</span><br><span class="line"><span class="meta">... </span>    to.append(element)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> to</span><br></pre></td></tr></table></figure><h2 id="开发陷阱-二-：闭包变量绑定"><a href="#开发陷阱-二-：闭包变量绑定" class="headerlink" title="开发陷阱(二)：闭包变量绑定"></a>开发陷阱(二)：闭包变量绑定</h2><p>看懂这个坑，需要先理解闭包，推荐一篇文章；</p><p><a href="https://zhuanlan.zhihu.com/p/26934085" target="_blank" rel="noopener">刘志军：一步一步教你认识Python闭包</a><br>​<br>下面我更换了 PPT 里的代码，坑看得更清楚一些。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    a = []</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line"><span class="meta">... </span>        <span class="function"><span class="keyword">def</span> <span class="title">demo</span><span class="params">(x)</span>:</span></span><br><span class="line"><span class="meta">... </span>            <span class="keyword">return</span> x*i</span><br><span class="line"><span class="meta">... </span>        a.append(demo)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> a</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> demo <span class="keyword">in</span> create():</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> demo(<span class="number">2</span>)</span><br><span class="line"><span class="meta">... </span><span class="comment"># 以为是 0 2 4 6 ，实际却是：</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><p>为什么会这样？<br>原因是：因为变量 i 是在闭包的作用域（demo 函数的外层作用域），而 Python 的闭包是迟绑定 ，这意味着闭包中用到的变量的值，是在内部函数被调用时查询得到的；</p><p>也就是说，<code>create()</code> 生成实例时，内部的 <code>for</code> 循环开始，使变量 i 的最终变成了 3，当随后循环调用闭包 <code>demo(2)</code> 时，在内部调用的 i 实际都是 3，要解决这个问题，可以如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    a = []</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line"><span class="meta">... </span>        <span class="function"><span class="keyword">def</span> <span class="title">demo</span><span class="params">(x, i=i)</span>:</span>  <span class="comment"># 把i绑定成demo的参数</span></span><br><span class="line"><span class="meta">... </span>            <span class="keyword">return</span> x*i</span><br><span class="line"><span class="meta">... </span>        a.append(demo)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> a</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 或者这样:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> operator <span class="keyword">import</span> mul</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">create_multipliers</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> [partial(mul, i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>)]</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 另外我发现也可以改成生成器表达式：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">create_multipliers</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> (<span class="keyword">lambda</span> x : i * x <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>))</span><br></pre></td></tr></table></figure><p>中间还有一些其他内建模块的用法，<a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014319347182373b696e637cc04430b8ee2d548ca1b36d000" target="_blank" rel="noopener">廖雪峰的教程</a>里都有，就不赘述</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于 Python 描述符(Descriptor)</title>
      <link href="/2017/10/09/%E5%85%B3%E4%BA%8E%20Python%20%E6%8F%8F%E8%BF%B0%E7%AC%A6(Descriptor)%20/"/>
      <url>/2017/10/09/%E5%85%B3%E4%BA%8E%20Python%20%E6%8F%8F%E8%BF%B0%E7%AC%A6(Descriptor)%20/</url>
      
        <content type="html"><![CDATA[<blockquote><p>描述符是在 Python 2.2 版本就被引用的特性，然而作为“元老”，却逐渐消失在 Python 教程的视野中。但当你了解它时，你就懂得了什么是 Python 的优雅之美。</p></blockquote><h2 id="什么是描述符"><a href="#什么是描述符" class="headerlink" title="什么是描述符"></a>什么是描述符</h2><h3 id="初识描述符"><a href="#初识描述符" class="headerlink" title="初识描述符"></a>初识描述符</h3><p>描述符的定义并不好理解，不如我们先见识一下它的功能：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> instance.__dict__.get(<span class="string">'_string'</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        instance._string = str(value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    username = String()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">m = Model()</span><br><span class="line">m.username = <span class="number">3154</span></span><br><span class="line">print(m.username)  <span class="comment"># 打印: '3154'</span></span><br></pre></td></tr></table></figure><p>如果你接触过 SQLAlchemy 类似的 ORM 库，你一定对上述代码实现的功能很眼熟。</p><p>没错，我们借助描述符，实现了简单的类似于 ORM 类型转换的功能，无论对 <code>username</code> 赋值什么类型，都会被自动转换成字符串。 </p><p>在最新的 Python 3.7 文档中这样介绍道：</p><blockquote><p>一般地，一个描述符是一个包含 “绑定行为” 的对象，对其属性的存取被描述符协议中定义的方法覆盖。<br>这些方法有：<code>__get__()</code>，<code>__set__()</code> 和 <code>__delete__()</code>。<br>如果某个对象中定义了这些方法中的任意一个，那么这个对象就可以被称为一个描述符。</p></blockquote><ul><li>描述符是一个有“绑定行为”的对象属性(object attribute)，它的访问控制会被描述器协议方法重写。</li><li>任何定义了 <code>__get__</code>,  <code>__set__</code> 或者  <code>__delete__</code> 任一方法的类称为描述符类，其实例对象便是一个描述符，这些方法称为描述符协议。</li><li>当对一个实例属性进行访问时，Python 会按 <code>obj.__dict__</code> → <code>type(obj).__dict__</code> → <code>type(obj)的父类.__dict__</code> 顺序进行查找，如果查找到目标属性并发现是一个描述符，Python 会调用描述符协议来改变默认的控制行为。</li><li>描述符是 <code>@property</code>  <code>@classmethod</code>  <code>@staticmethod</code> 和 <code>super</code> 的底层实现机制。</li></ul><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>同时定义了 <code>__get__</code> 和 <code>__set__</code> 的描述符称为 数据描述符(data descriptor)；仅定义了 <code>__get__</code> 的称为 非数据描述符(non-data descriptor) 。两者区别在于：如果 <code>obj.__dict__</code>  中有与描述符同名的属性，若描述符是数据描述符，则优先调用描述符，若是非数据描述符，则优先使用 <code>obj.__dict__</code> 中属性。</li><li>描述符协议必须定义在类的层次上，否则无法被自动调用。</li></ul><h2 id="描述符协议"><a href="#描述符协议" class="headerlink" title="描述符协议"></a>描述符协议</h2><p><code>__get__(self, instance, owner)</code><br><em>:param**self:</em> 描述符对象本身<br><em>:param**instance:</em> 使用描述符的对象的实例<br><em>:param**owner:</em> 使用描述符的对象拥有者</p><p><code>__set__(self, instance, value)</code><br><em>:param**value:</em> 对描述符的赋值</p><p><code>__delete__(self, instance)</code></p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">实现惰性求值(访问时才计算，并将值缓存)</span></span><br><span class="line"><span class="string">利用了 obj.__dict__ 优先级高于 non-data descriptor 的特性</span></span><br><span class="line"><span class="string">第一次调用 __get__ 以同名属性存于实例字典中，之后就不再调用 __get__</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lazyproperty</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, fun)</span>:</span></span><br><span class="line">        self.fun = fun</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">        print(self, instance, owner)</span><br><span class="line">        <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        value = self.fun(instance)</span><br><span class="line">        setattr(instance, self.fun.__name__, value)</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, radius)</span>:</span></span><br><span class="line">        self.radius = radius</span><br><span class="line"></span><br><span class="line"><span class="meta">    @lazyproperty</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">area</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Computing area'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.1415</span> * self.radius ** <span class="number">2</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">实现只读属性(实例属性初始化后无法被修改)</span></span><br><span class="line"><span class="string">利用了 data descriptor 优先级高于 obj.__dict__ 的特性</span></span><br><span class="line"><span class="string">当试图对属性赋值时，总会先调用 __set__ 方法从而抛出异常</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">readonly_property</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, fun)</span>:</span></span><br><span class="line">        self.fun = fun</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.fun(instance)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> AttributeError(</span><br><span class="line">            <span class="string">"'%s' is not modifiable"</span> % self.fun.__name__</span><br><span class="line">         )</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, radius)</span>:</span></span><br><span class="line">        self.radius = radius</span><br><span class="line"></span><br><span class="line"><span class="meta">    @readonly_property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pi</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.1415</span></span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://pyzh.readthedocs.io/en/latest/Descriptor-HOW-TO-Guide.html" target="_blank" rel="noopener">https://pyzh.readthedocs.io/en/latest/Descriptor-HOW-TO-Guide.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程爬取招聘网站，帮你年后找工作</title>
      <link href="/2017/10/05/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%88%AC%E5%8F%96%E6%8B%9B%E8%81%98%E7%BD%91%E7%AB%99%EF%BC%8C%E5%B8%AE%E4%BD%A0%E5%B9%B4%E5%90%8E%E6%89%BE%E5%B7%A5%E4%BD%9C/"/>
      <url>/2017/10/05/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%88%AC%E5%8F%96%E6%8B%9B%E8%81%98%E7%BD%91%E7%AB%99%EF%BC%8C%E5%B8%AE%E4%BD%A0%E5%B9%B4%E5%90%8E%E6%89%BE%E5%B7%A5%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本爬虫仅供学习交流，请勿将爬取数据进行非法使用。</p></blockquote><h2 id="功能简介"><a href="#功能简介" class="headerlink" title="功能简介"></a>功能简介</h2><p>本爬虫可爬取各大互联网行业常用招聘网站(目前包括 拉勾网、BOSS直聘、前程无忧、猎聘网，更多可自定义)，采集职位主要信息输出到 csv 文件；<br>爬虫和文件写入独立两个进程(其实没必要，为了练习)，进程A对每个网站的爬虫启动多线程，每个爬虫以生成器方式迭代返回数据，通过队列传输给进程B进行写入。</p><h2 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h2><ul><li>Python 3</li><li>requests</li><li>lxml</li></ul><h2 id="代码简介"><a href="#代码简介" class="headerlink" title="代码简介"></a>代码简介</h2><p>首先定义了爬虫的元类和基类，元类用来自动注册爬虫类到列表，进程只要遍历这个列表就能获得所有爬虫类了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># job_spider/spider.py</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpiderMeta</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="string">"""爬虫类的元类，注册子类到列表，爬虫类指定此元类才能加入进程"""</span></span><br><span class="line"></span><br><span class="line">    spiders = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(mcs, name, bases, attrs)</span>:</span></span><br><span class="line">        mcs.spiders.append(type.__new__(mcs, name, bases, attrs))</span><br><span class="line">        <span class="keyword">return</span> type.__new__(mcs, name, bases, attrs)</span><br></pre></td></tr></table></figure><p>因为发现这些招聘网站对访问限制很高，所以在基类里实现了一个可以保持请求间隔和带默认 headers 的请求方法，每次请求都会计算与上次请求的间隔，间隔不够就等待，这样就不用每次 <code>requests</code> 后边都跟着 <code>time.sleep</code> 了；另外还加入了随机系数来对间隔进行浮动。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># job_spider/spider.py</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseSpider</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""爬虫类的基类，提供需要的属性和方法"""</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 省略部分代码</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">request</span><span class="params">(self, method=<span class="string">'get'</span>, url=None, encoding=None, **kwargs)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        根据爬虫类重新封装的`requests`，可保持请求间隔，并带有默认头部</span></span><br><span class="line"><span class="string">        :param method: 请求方法，`get`或`post`等</span></span><br><span class="line"><span class="string">        :param url: 请求链接</span></span><br><span class="line"><span class="string">        :param encoding: 指定对返回对象进行编码</span></span><br><span class="line"><span class="string">        :param kwargs: 其他`requests`自带的参数</span></span><br><span class="line"><span class="string">        :return: Response 对象</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 没有指定头部则使用默认头部</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> kwargs.get(<span class="string">'headers'</span>):</span><br><span class="line">            kwargs[<span class="string">'headers'</span>] = self.headers</span><br><span class="line">        <span class="comment"># 随机生成系数对间隔产生变化</span></span><br><span class="line">        rand_multi = random.uniform(<span class="number">0.8</span>, <span class="number">1.2</span>)</span><br><span class="line">        <span class="comment"># 距离上次请求的间隔</span></span><br><span class="line">        interval = time.time()-self._time_recode</span><br><span class="line">        <span class="comment"># 如间隔小于最短间隔，则进行等待</span></span><br><span class="line">        <span class="keyword">if</span> interval &lt; self.request_sleep:</span><br><span class="line">            time.sleep((self.request_sleep-interval)*rand_multi)</span><br><span class="line">        resp = getattr(requests, method)(url, **kwargs)</span><br><span class="line">        <span class="comment"># 请求完重新记录时间戳</span></span><br><span class="line">        self._time_recode = time.time()</span><br><span class="line">        <span class="keyword">if</span> encoding:</span><br><span class="line">            resp.encoding = encoding</span><br><span class="line">        <span class="keyword">return</span> resp</span><br></pre></td></tr></table></figure><p>爬虫具体代码就不说了，主要是实现一个 <code>crawl</code> 方法，用 <code>yield</code> 返回数据。</p><p>下面是进程的代码，将元类列表的爬虫类分别传入 <code>iter_spider</code> 中，并启动一个线程即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># job_spider/process.py</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpiderProcess</span><span class="params">(Process)</span>:</span></span><br><span class="line">    <span class="string">"""爬虫进程"""</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 省略部分代码</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">iter_spider</span><span class="params">(self, spider)</span>:</span></span><br><span class="line">        <span class="string">"""对爬虫类的`crawl`方法进行迭代，数据送入队列传给另一进程"""</span></span><br><span class="line">        setattr(spider, <span class="string">'job'</span>, self.job)</span><br><span class="line">        setattr(spider, <span class="string">'city'</span>, self.city)</span><br><span class="line">        generator = spider.crawl()</span><br><span class="line">        <span class="keyword">if</span> generator:</span><br><span class="line">            <span class="keyword">for</span> result <span class="keyword">in</span> spider.crawl():</span><br><span class="line">                self.data_queue.put(result)</span><br><span class="line">                self.logger.debug(<span class="string">'%s %s %50s...(省略)'</span> % (result.get(<span class="string">'title'</span>), result.get(<span class="string">'url'</span>),</span><br><span class="line">                                  result.get(<span class="string">'description'</span>)))</span><br><span class="line">        self.logger.info(<span class="string">'%s 爬虫已结束'</span> % spider.__class__.__name__)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""对每个爬虫类启动单独线程"""</span></span><br><span class="line">        self.set_logging()</span><br><span class="line">        spiders = [cls() <span class="keyword">for</span> cls <span class="keyword">in</span> SpiderMeta.spiders]</span><br><span class="line">        spider_count = len(spiders)</span><br><span class="line">        threads = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(spider_count):</span><br><span class="line">            t = Thread(target=self.iter_spider, args=(spiders[i], ))</span><br><span class="line">            t.setDaemon(<span class="literal">True</span>)</span><br><span class="line">            t.start()</span><br><span class="line">            threads.append(t)</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>写数据进程比较简单，主要是按当前时间创建 csv 然后从队列里获取数据写入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># job_spider/process.py</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WriterProcess</span><span class="params">(Process)</span>:</span></span><br><span class="line">    <span class="string">"""写数据进程"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data_queue)</span>:</span></span><br><span class="line">        Process.__init__(self)</span><br><span class="line">        self.data_queue = data_queue</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""以当前时间创建 csv 文件，并从队列中获取数据写入"""</span></span><br><span class="line">        csv_name = datetime.now().strftime(<span class="string">'%Y-%m-%d %H-%M-%S'</span>) + <span class="string">'.csv'</span></span><br><span class="line">        <span class="keyword">with</span> open(csv_name, <span class="string">'w'</span>, encoding=<span class="string">'utf_8_sig'</span>, newline=<span class="string">''</span>) <span class="keyword">as</span> f:</span><br><span class="line">            writer = csv.writer(f)</span><br><span class="line">            writer.writerow([<span class="string">'标题'</span>, <span class="string">'公司'</span>, <span class="string">'薪水'</span>, <span class="string">'经验'</span>,</span><br><span class="line">                             <span class="string">'学历'</span>, <span class="string">'链接'</span>, <span class="string">'描述'</span>])</span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    result = self.data_queue.get(timeout=<span class="number">90</span>)</span><br><span class="line">                    <span class="keyword">if</span> result:</span><br><span class="line">                        row = [</span><br><span class="line">                            result.get(<span class="string">'title'</span>), result.get(<span class="string">'company'</span>),</span><br><span class="line">                            result.get(<span class="string">'salary'</span>), result.get(<span class="string">'experience'</span>),</span><br><span class="line">                            result.get(<span class="string">'education'</span>), result.get(<span class="string">'url'</span>),</span><br><span class="line">                            result.get(<span class="string">'description'</span>)</span><br><span class="line">                        ]</span><br><span class="line">                        writer.writerow(row)</span><br><span class="line">                <span class="keyword">except</span> queue.Empty:</span><br><span class="line">                    f.close()</span><br></pre></td></tr></table></figure><h2 id="运行方式"><a href="#运行方式" class="headerlink" title="运行方式"></a>运行方式</h2><p>方法一：使用命令行参数<br><code>$ python3 run.py -j 后端 -c 北京</code></p><p>方法二：直接运行，根据提示输入参数<br><code>$ python3 run.py</code><br>请输入职业：后端<br>请输入城市：北京  </p><p>如 <code>$ python3 run.py -j pyhton -c 上海</code>，结束后会生成 Excel 表格：</p><p><img src="https://pic2.zhimg.com/v2-c0f3e2a24cd52f1d1d72e7ea2bfbddf5_b.jpg" alt="方便筛选和统计"></p><h2 id="代码仓库"><a href="#代码仓库" class="headerlink" title="代码仓库"></a>代码仓库</h2><p><a href="https://github.com/zkqiang/Job-Spider" target="_blank" rel="noopener">https://github.com/zkqiang/Job-Spider</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python3 中 configparser 模块解析配置的用法详解</title>
      <link href="/2017/09/19/Python3%20%E4%B8%AD%20configparser%20%E6%A8%A1%E5%9D%97%E8%A7%A3%E6%9E%90%E9%85%8D%E7%BD%AE%E7%9A%84%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
      <url>/2017/09/19/Python3%20%E4%B8%AD%20configparser%20%E6%A8%A1%E5%9D%97%E8%A7%A3%E6%9E%90%E9%85%8D%E7%BD%AE%E7%9A%84%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="configparser-简介"><a href="#configparser-简介" class="headerlink" title="configparser 简介"></a>configparser 简介</h3><p>configparser 是 Pyhton 标准库中用来解析配置文件的模块，并且内置方法和字典非常接近。Python2.x 中名为 ConfigParser，3.x 已更名小写，并加入了一些新功能。<br>配置文件的格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[DEFAULT]</span><br><span class="line">ServerAliveInterval &#x3D; 45</span><br><span class="line">Compression &#x3D; yes</span><br><span class="line">CompressionLevel &#x3D; 9</span><br><span class="line">ForwardX11 &#x3D; yes</span><br><span class="line"></span><br><span class="line">[bitbucket.org]</span><br><span class="line">User &#x3D; Tom</span><br><span class="line"></span><br><span class="line">[topsecret.com]</span><br><span class="line">Port: 50022</span><br><span class="line">ForwardX11: no</span><br></pre></td></tr></table></figure><p>“[ ]”包含的为 section，section 下面为类似于 key - value 的配置内容；<br>configparser 默认支持 ‘=’ ‘：’ 两种分隔。</p><hr><h3 id="configparser-常用方法"><a href="#configparser-常用方法" class="headerlink" title="configparser 常用方法"></a>configparser 常用方法</h3><h4 id="初始化实例"><a href="#初始化实例" class="headerlink" title="初始化实例"></a>初始化实例</h4><p>使用 configparser 首先需要初始化实例，并读取配置文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> configparser</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>config = configparser.ConfigParser()<span class="comment"># 注意大小写</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>config.read(<span class="string">"config.ini"</span>)<span class="comment"># 配置文件的路径</span></span><br><span class="line">[<span class="string">"config.ini"</span>]</span><br></pre></td></tr></table></figure><p>或者可以直接读字典</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = configparser.ConfigParser()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.read_dict(&#123;<span class="string">'section1'</span>: &#123;<span class="string">'key1'</span>: <span class="string">'value1'</span>,</span><br><span class="line"><span class="meta">... </span>                               <span class="string">'key2'</span>: <span class="string">'value2'</span>,</span><br><span class="line"><span class="meta">... </span>                               <span class="string">'key3'</span>: <span class="string">'value3'</span>&#125;,</span><br><span class="line"><span class="meta">... </span>                  <span class="string">'section2'</span>: &#123;<span class="string">'keyA'</span>: <span class="string">'valueA'</span>,</span><br><span class="line"><span class="meta">... </span>                               <span class="string">'keyB'</span>: <span class="string">'valueB'</span>,</span><br><span class="line"><span class="meta">... </span>                               <span class="string">'keyC'</span>: <span class="string">'valueC'</span>&#125;,</span><br><span class="line"><span class="meta">... </span>                  <span class="string">'section3'</span>: &#123;<span class="string">'foo'</span>: <span class="string">'x'</span>,</span><br><span class="line"><span class="meta">... </span>                               <span class="string">'bar'</span>: <span class="string">'y'</span>,</span><br><span class="line"><span class="meta">... </span>                               <span class="string">'baz'</span>: <span class="string">'z'</span>&#125;</span><br><span class="line"><span class="meta">... </span>&#125;)</span><br></pre></td></tr></table></figure><h4 id="获取所有-sections"><a href="#获取所有-sections" class="headerlink" title="获取所有 sections"></a>获取所有 sections</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>config.sections()</span><br><span class="line">[<span class="string">'bitbucket.org'</span>, <span class="string">'topsecret.com'</span>]    <span class="comment"># 注意会过滤掉[DEFAULT]</span></span><br></pre></td></tr></table></figure><h4 id="获取指定-section-的-keys-amp-values"><a href="#获取指定-section-的-keys-amp-values" class="headerlink" title="获取指定 section 的 keys &amp; values"></a>获取指定 section 的 keys &amp; values</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>config.items(<span class="string">'topsecret.com'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[(<span class="string">'port'</span>, <span class="string">'50022'</span>), (<span class="string">'forwardx11'</span>, <span class="string">'no'</span>)]    <span class="comment"># 注意items()返回的字符串会全变成小写</span></span><br></pre></td></tr></table></figure><h4 id="获取指定-section-的-keys"><a href="#获取指定-section-的-keys" class="headerlink" title="获取指定 section 的 keys"></a>获取指定 section 的 keys</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>config.options(<span class="string">'topsecret.com'</span>)</span><br><span class="line">[<span class="string">'Port'</span>, <span class="string">'ForwardX11'</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> option <span class="keyword">in</span> config[<span class="string">'topsecret.com'</span>]:</span><br><span class="line">...    print(option)</span><br><span class="line">Port</span><br><span class="line">ForwardX11</span><br></pre></td></tr></table></figure><h4 id="获取指定-key-的-value"><a href="#获取指定-key-的-value" class="headerlink" title="获取指定 key 的 value"></a>获取指定 key 的 value</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>config[<span class="string">'bitbucket.org'</span>][<span class="string">'User'</span>]</span><br><span class="line"><span class="string">'Tom'</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>config.get(<span class="string">'bitbucket.org'</span>, <span class="string">'User'</span>)</span><br><span class="line"><span class="string">'Tom'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>config.getint(<span class="string">'topsecret.com'</span>, <span class="string">'Port'</span>)</span><br><span class="line"><span class="number">50022</span></span><br></pre></td></tr></table></figure><h4 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'DEFAULT'</span> <span class="keyword">in</span> config</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'test'</span> <span class="keyword">in</span> config[<span class="string">'section_test'</span>]</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Tom'</span> <span class="keyword">in</span> config[<span class="string">'bitbucket.org'</span>][<span class="string">'User'</span>]</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>config.has_section(<span class="string">'bitbucket.org'</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>config.has_option(<span class="string">'section_test'</span>, <span class="string">'test'</span>)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><h4 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>config.add_section(<span class="string">'Section_1'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>config.set(<span class="string">'Section_1'</span>, <span class="string">'key_1'</span>, <span class="string">'value_1'</span>)    <span class="comment"># 注意键值是用set()方法</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>config.write(open(<span class="string">'config.ini'</span>, <span class="string">'w'</span>))    <span class="comment"># 一定要写入才生效</span></span><br></pre></td></tr></table></figure><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>config.remove_option(<span class="string">'Section_1'</span>, <span class="string">'key_1'</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>config.remove_section(<span class="string">'Section_1'</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>config.clear()<span class="comment"># 清空除[DEFAULT]之外所有内容</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>config.write(open(<span class="string">'config.ini'</span>, <span class="string">'w'</span>))</span><br></pre></td></tr></table></figure><hr><h3 id="关于-DEFAULT"><a href="#关于-DEFAULT" class="headerlink" title="关于 [DEFAULT]"></a>关于 [DEFAULT]</h3><p>[DEFAULT] 一般包含 ini 格式配置文件的默认项，所以 configparser 部分方法会自动跳过这个 section 。<br>前面已经提到 sections() 是获取不到的，还有删除方法对 [DEFAULT] 也无效：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; config.remove_section(&#39;DEFAULT&#39;)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; config.clear()</span><br><span class="line">&gt;&gt;&gt; &#39;DEFAULT&#39; in config</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; &#39;ForwardX11&#39; in config[&#39;DEFAULT&#39;]</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; config.sections()</span><br><span class="line">[]</span><br></pre></td></tr></table></figure><p>但指定删除和修改 [DEFAULT] 里的 keys &amp; values 是可以的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; config.remove_option(&#39;DEFAULT&#39;, &#39;ForwardX11&#39;)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; config.set(&#39;DEFAULT&#39;, &#39;ForwardX11&#39;,&#39;no&#39;)</span><br><span class="line">&gt;&gt;&gt; config[&#39;DEFAULT&#39;][&#39;ForwardX11&#39;]</span><br><span class="line">&#39;no&#39;</span><br></pre></td></tr></table></figure><p>还有个特殊的是，has_section() 也无效，可以和 in 区别使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; config.has_section(&#39;DEFAULT&#39;)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; &#39;DEFAULT&#39; in config</span><br><span class="line">True</span><br></pre></td></tr></table></figure><br/><p>更多用法请看官方文档：<br>&lt;<a href="https://docs.python.org/3.6/library/configparser.html" target="_blank" rel="noopener">https://docs.python.org/3.6/library/configparser.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
